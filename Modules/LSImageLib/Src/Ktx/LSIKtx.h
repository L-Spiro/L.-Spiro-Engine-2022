/**
 * Copyright L. Spiro 2021
 * All rights reserved.
 *
 * Written by:	Shawn (L. Spiro) Wilcoxen
 *
 * This code may not be sold or traded for any personal gain without express written consent.  You may use
 *	this code in your own projects and modify it to suit your needs as long as this disclaimer remains intact.
 *	You may not take credit for having written this code.
 *
 *
 * Description: Handles loading of .KTX files.
 */


#ifndef __LSI_KTX_H__
#define __LSI_KTX_H__

#include "../LSIImageLib.h"
#include "FloatX/LSMFloatX.h"
#include "LSIKtxTexture.h"
#include "Vector/LSTLVector.h"

#define LSI_USE_KHRONOS
//#define LSI_PRINT_TABLE

#pragma warning( push )

// warning C4127: conditional expression is constant
#pragma warning( disable : 4127 )

//  warning C4293: '<<': shift count negative or too big, undefined behavior
#pragma warning( disable : 4293 )

//  warning C4723: potential divide by 0
#pragma warning( disable : 4723 )

/** 16-bit float metrics. */
#define LSI_FLOAT16																	5, 10, true, false

/** 11-bit float metrics. */
#define LSI_FLOAT11																	5, 6, false, false

/** 10-bit float metrics. */
#define LSI_FLOAT10																	5, 5, false, false

/** RGB9_E5 bias. */
#define LSI_RGB9E5_EXP_BIAS															15

/** RGB9_E5 mantissa bits. */
#define LSI_RGB9E5_MANTISSA_BITS													9

/** RGB9_E5 exponent bits. */
#define LSI_RGB9E5_EXPONENT_BITS													5

/** RGB9_E5 max valid exponent bias. */
#define LSI_RGB9E5_MAX_VALID_BIASED_EXP												31

/** RGB9_E5 max exponent. */
#define LSI_MAX_RGB9E5_EXP															(LSI_RGB9E5_MAX_VALID_BIASED_EXP - LSI_RGB9E5_EXP_BIAS)

/** RGB9_E5 mantissa values. */
#define LSI_RGB9E5_MANTISSA_VALUES													(1 << LSI_RGB9E5_MANTISSA_BITS)

/** RGB9_E5 max mantissa. */
#define LSI_MAX_RGB9E5_MANTISSA														(LSI_RGB9E5_MANTISSA_VALUES - 1)

/** RGB9_E5 max. */
#define LSI_MAX_RGB9E5																(static_cast<float>(LSI_MAX_RGB9E5_MANTISSA) / LSI_RGB9E5_MANTISSA_VALUES * (1 << LSI_MAX_RGB9E5_EXP))

/** RGB9_E5 epsilon. */
#define LSI_EPSILON_RGB9E5															((1.0 / LSI_RGB9E5_MANTISSA_VALUES) / (1 << LSI_RGB9E5_EXP_BIAS))

namespace lsi {

	// == Enumerations.
	/**
	 * glType values.  Table 8.2 of OpenGL 4.4.
	 */
	enum LSI_KTX_TYPE : uint16_t {
		LSI_KT_GL_BYTE																= 0x1400, /** GL_BYTE */
		LSI_KT_GL_UNSIGNED_BYTE														= 0x1401, /** GL_UNSIGNED_BYTE */
		LSI_KT_GL_SHORT																= 0x1402, /** GL_SHORT */
		LSI_KT_GL_UNSIGNED_SHORT													= 0x1403, /** GL_UNSIGNED_SHORT */
		LSI_KT_GL_INT																= 0x1404, /** GL_INT */
		LSI_KT_GL_UNSIGNED_INT														= 0x1405, /** GL_UNSIGNED_INT */
		LSI_KT_GL_INT64																= 0x140E, /** GL_INT64 */
		LSI_KT_GL_UNSIGNED_INT64													= 0x140F, /** GL_UNSIGNED_INT64 */
		LSI_KT_GL_HALF_FLOAT														= 0x140B, /** GL_HALF_FLOAT */
		LSI_KT_GL_HALF_FLOAT_OES													= 0x8D61, /** GL_HALF_FLOAT_OES */
		LSI_KT_GL_FLOAT																= 0x1406, /** GL_FLOAT */
		LSI_KT_GL_DOUBLE															= 0x140A, /** GL_DOUBLE */
		LSI_KT_GL_UNSIGNED_BYTE_3_3_2												= 0x8032, /** GL_UNSIGNED_BYTE_3_3_2 */
		LSI_KT_GL_UNSIGNED_BYTE_2_3_3_REV											= 0x8362, /** GL_UNSIGNED_BYTE_2_3_3_REV */
		LSI_KT_GL_UNSIGNED_SHORT_5_6_5												= 0x8363, /** GL_UNSIGNED_SHORT_5_6_5 */
		LSI_KT_GL_UNSIGNED_SHORT_5_6_5_REV											= 0x8364, /** GL_UNSIGNED_SHORT_5_6_5_REV */
		LSI_KT_GL_UNSIGNED_SHORT_4_4_4_4											= 0x8033, /** GL_UNSIGNED_SHORT_4_4_4_4 */
		LSI_KT_GL_UNSIGNED_SHORT_4_4_4_4_REV										= 0x8365, /** GL_UNSIGNED_SHORT_4_4_4_4_REV */
		LSI_KT_GL_UNSIGNED_SHORT_5_5_5_1											= 0x8034, /** GL_UNSIGNED_SHORT_5_5_5_1 */
		LSI_KT_GL_UNSIGNED_SHORT_1_5_5_5_REV										= 0x8366, /** GL_UNSIGNED_SHORT_1_5_5_5_REV */
		LSI_KT_GL_UNSIGNED_INT_8_8_8_8												= 0x8035, /** GL_UNSIGNED_INT_8_8_8_8 */
		LSI_KT_GL_UNSIGNED_INT_8_8_8_8_REV											= 0x8367, /** GL_UNSIGNED_INT_8_8_8_8_REV */
		LSI_KT_GL_UNSIGNED_INT_10_10_10_2											= 0x8036, /** GL_UNSIGNED_INT_10_10_10_2 */
		LSI_KT_GL_UNSIGNED_INT_2_10_10_10_REV										= 0x8368, /** GL_UNSIGNED_INT_2_10_10_10_REV */
		LSI_KT_GL_UNSIGNED_INT_10F_11F_11F_REV										= 0x8C3B, /** GL_UNSIGNED_INT_10F_11F_11F_REV */
		LSI_KT_GL_UNSIGNED_INT_5_9_9_9_REV											= 0x8C3E, /** GL_UNSIGNED_INT_5_9_9_9_REV */
		LSI_KT_GL_UNSIGNED_INT_24_8													= 0x84FA, /** GL_UNSIGNED_INT_24_8 */
		LSI_KT_GL_FLOAT_32_UNSIGNED_INT_24_8_REV									= 0x8DAD, /** GL_FLOAT_32_UNSIGNED_INT_24_8_REV */
		LSI_KT_0																	= 0,
	};

	/**
	 * glFormat values.  Table 8.3 of OpenGL 4.4.
	 */
	enum LSI_KTX_FORMAT : uint16_t {
		LSI_KF_GL_RED																= 0x1903, /** GL_RED */
		LSI_KF_GL_GREEN																= 0x1904, /** GL_GREEN */
		LSI_KF_GL_BLUE																= 0x1905, /** GL_BLUE */
		LSI_KF_GL_ALPHA																= 0x1906, /** GL_ALPHA */
		LSI_KF_GL_LUMINANCE															= 0x1909, /** GL_LUMINANCE */
		LSI_KF_GL_SLUMINANCE														= 0x8C46, /** GL_SLUMINANCE */
		LSI_KF_GL_LUMINANCE_ALPHA													= 0x190A, /** GL_LUMINANCE_ALPHA */
		LSI_KF_GL_SLUMINANCE_ALPHA													= 0x8C44, /** GL_SLUMINANCE_ALPHA */
		LSI_KF_GL_INTENSITY															= 0x8049, /** GL_INTENSITY */
		LSI_KF_GL_RG																= 0x8227, /** GL_RG */
		LSI_KF_GL_RGB																= 0x1907, /** GL_RGB */
		LSI_KF_GL_BGR																= 0x80E0, /** GL_BGR */
		LSI_KF_GL_RGBA																= 0x1908, /** GL_RGBA */
		LSI_KF_GL_BGRA																= 0x80E1, /** GL_BGRA */
		LSI_KF_GL_RED_INTEGER														= 0x8D94, /** GL_RED_INTEGER */
		LSI_KF_GL_GREEN_INTEGER														= 0x8D95, /** GL_GREEN_INTEGER */
		LSI_KF_GL_BLUE_INTEGER														= 0x8D96, /** GL_BLUE_INTEGER */
		LSI_KF_GL_ALPHA_INTEGER														= 0x8D97, /** GL_ALPHA_INTEGER */
		LSI_KF_GL_LUMINANCE_INTEGER													= 0x8D9C, /** GL_LUMINANCE_INTEGER */
		LSI_KF_GL_LUMINANCE_ALPHA_INTEGER											= 0x8D9D, /** GL_LUMINANCE_ALPHA_INTEGER */
		LSI_KF_GL_RG_INTEGER														= 0x8228, /** GL_RG_INTEGER */
		LSI_KF_GL_RGB_INTEGER														= 0x8D98, /** GL_RGB_INTEGER */
		LSI_KF_GL_BGR_INTEGER														= 0x8D9A, /** GL_BGR_INTEGER */
		LSI_KF_GL_RGBA_INTEGER														= 0x8D99, /** GL_RGBA_INTEGER */
		LSI_KF_GL_BGRA_INTEGER														= 0x8D9B, /** GL_BGRA_INTEGER */
		LSI_KF_GL_COLOR_INDEX														= 0x1900, /** GL_COLOR_INDEX */
		LSI_KF_GL_STENCIL_INDEX														= 0x1901, /** GL_STENCIL_INDEX */
		LSI_KF_GL_DEPTH_COMPONENT													= 0x1902, /** GL_DEPTH_COMPONENT */
		LSI_KF_GL_DEPTH_STENCIL														= 0x84F9, /** GL_DEPTH_STENCIL */
	};

	/**
	 * glInternalFormat values.  Tables 8.12, 8.13, and 8.14 of OpenGL 4.4.
	 */
	enum LSI_KTX_INTERNAL_FORMAT : uint16_t {
		//
		// 8 bits per component
		//
		LSI_KIF_GL_R8																= 0x8229, /** GL_R8 */
		LSI_KIF_GL_RG8																= 0x822B, /** GL_RG8 */
		LSI_KIF_GL_RGB8																= 0x8051, /** GL_RGB8 */
		LSI_KIF_GL_RGBA8															= 0x8058, /** GL_RGBA8 */
		LSI_KIF_GL_R8_SNORM															= 0x8F94, /** GL_R8_SNORM */
		LSI_KIF_GL_RG8_SNORM														= 0x8F95, /** GL_RG8_SNORM */
		LSI_KIF_GL_RGB8_SNORM														= 0x8F96, /** GL_RGB8_SNORM */
		LSI_KIF_GL_RGBA8_SNORM														= 0x8F97, /** GL_RGBA8_SNORM */
		LSI_KIF_GL_R8UI																= 0x8232, /** GL_R8UI */
		LSI_KIF_GL_RG8UI															= 0x8238, /** GL_RG8UI */
		LSI_KIF_GL_RGB8UI															= 0x8D7D, /** GL_RGB8UI */
		LSI_KIF_GL_RGBA8UI															= 0x8D7C, /** GL_RGBA8UI */
		LSI_KIF_GL_R8I																= 0x8231, /** GL_R8I */
		LSI_KIF_GL_RG8I																= 0x8237, /** GL_RG8I */
		LSI_KIF_GL_RGB8I															= 0x8D8F, /** GL_RGB8I */
		LSI_KIF_GL_RGBA8I															= 0x8D8E, /** GL_RGBA8I */
		LSI_KIF_GL_SR8																= 0x8FBD, /** GL_SR8 */
		LSI_KIF_GL_SRG8																= 0x8FBE, /** GL_SRG8 */
		LSI_KIF_GL_SRGB8															= 0x8C41, /** GL_SRGB8 */
		LSI_KIF_GL_SRGB8_ALPHA8														= 0x8C43, /** GL_SRGB8_ALPHA8 */
		//
		// 16 bits per component
		//
		LSI_KIF_GL_R16																= 0x822A, /** GL_R16 */
		LSI_KIF_GL_RG16																= 0x822C, /** GL_RG16 */
		LSI_KIF_GL_RGB16															= 0x8054, /** GL_RGB16 */
		LSI_KIF_GL_RGBA16															= 0x805B, /** GL_RGBA16 */
		LSI_KIF_GL_R16_SNORM														= 0x8F98, /** GL_R16_SNORM */
		LSI_KIF_GL_RG16_SNORM														= 0x8F99, /** GL_RG16_SNORM */
		LSI_KIF_GL_RGB16_SNORM														= 0x8F9A, /** GL_RGB16_SNORM */
		LSI_KIF_GL_RGBA16_SNORM														= 0x8F9B, /** GL_RGBA16_SNORM */
		LSI_KIF_GL_R16UI															= 0x8234, /** GL_R16UI */
		LSI_KIF_GL_RG16UI															= 0x823A, /** GL_RG16UI */
		LSI_KIF_GL_RGB16UI															= 0x8D77, /** GL_RGB16UI */
		LSI_KIF_GL_RGBA16UI															= 0x8D76, /** GL_RGBA16UI */
		LSI_KIF_GL_R16I																= 0x8233, /** GL_R16I */
		LSI_KIF_GL_RG16I															= 0x8239, /** GL_RG16I */
		LSI_KIF_GL_RGB16I															= 0x8D89, /** GL_RGB16I */
		LSI_KIF_GL_RGBA16I															= 0x8D88, /** GL_RGBA16I */
		LSI_KIF_GL_R16F																= 0x822D, /** GL_R16F */
		LSI_KIF_GL_RG16F															= 0x822F, /** GL_RG16F */
		LSI_KIF_GL_RGB16F															= 0x881B, /** GL_RGB16F */
		LSI_KIF_GL_RGBA16F															= 0x881A, /** GL_RGBA16F */
		//
		// 32 bits per component
		//
		LSI_KIF_GL_R32UI															= 0x8236, /** GL_R32UI */
		LSI_KIF_GL_RG32UI															= 0x823C, /** GL_RG32UI */
		LSI_KIF_GL_RGB32UI															= 0x8D71, /** GL_RGB32UI */
		LSI_KIF_GL_RGBA32UI															= 0x8D70, /** GL_RGBA32UI */
		LSI_KIF_GL_R32I																= 0x8235, /** GL_R32I */
		LSI_KIF_GL_RG32I															= 0x823B, /** GL_RG32I */
		LSI_KIF_GL_RGB32I															= 0x8D83, /** GL_RGB32I */
		LSI_KIF_GL_RGBA32I															= 0x8D82, /** GL_RGBA32I */
		LSI_KIF_GL_R32F																= 0x822E, /** GL_R32F */
		LSI_KIF_GL_RG32F															= 0x8230, /** GL_RG32F */
		LSI_KIF_GL_RGB32F															= 0x8815, /** GL_RGB32F */
		LSI_KIF_GL_RGBA32F															= 0x8814, /** GL_RGBA32F */
		//
		// Packed
		//
		LSI_KIF_GL_R3_G3_B2															= 0x2A10, /** GL_R3_G3_B2 */
		LSI_KIF_GL_RGB4																= 0x804F, /** GL_RGB4 */
		LSI_KIF_GL_RGB5																= 0x8050, /** GL_RGB5 */
		LSI_KIF_GL_RGB565															= 0x8D62, /** GL_RGB565 */
		LSI_KIF_GL_RGB10															= 0x8052, /** GL_RGB10 */
		LSI_KIF_GL_RGB12															= 0x8053, /** GL_RGB12 */
		LSI_KIF_GL_RGBA2															= 0x8055, /** GL_RGBA2 */
		LSI_KIF_GL_RGBA4															= 0x8056, /** GL_RGBA4 */
		LSI_KIF_GL_RGBA12															= 0x805A, /** GL_RGBA12 */
		LSI_KIF_GL_RGB5_A1															= 0x8057, /** GL_RGB5_A1 */
		LSI_KIF_GL_RGB10_A2															= 0x8059, /** GL_RGB10_A2 */
		LSI_KIF_GL_RGB10_A2UI														= 0x906F, /** GL_RGB10_A2UI */
		LSI_KIF_GL_R11F_G11F_B10F													= 0x8C3A, /** GL_R11F_G11F_B10F */
		LSI_KIF_GL_RGB9_E5															= 0x8C3D, /** GL_RGB9_E5 */
		//
		// Alpha
		//
		LSI_KIF_GL_ALPHA4															= 0x803B, /** GL_ALPHA4 */
		LSI_KIF_GL_ALPHA8															= 0x803C, /** GL_ALPHA8 */
		LSI_KIF_GL_ALPHA8_SNORM														= 0x9014, /** GL_ALPHA8_SNORM */
		LSI_KIF_GL_ALPHA8UI_EXT														= 0x8D7E, /** GL_ALPHA8UI_EXT */
		LSI_KIF_GL_ALPHA8I_EXT														= 0x8D90, /** GL_ALPHA8I_EXT */
		LSI_KIF_GL_ALPHA12															= 0x803D, /** GL_ALPHA12 */
		LSI_KIF_GL_ALPHA16															= 0x803E, /** GL_ALPHA16 */
		LSI_KIF_GL_ALPHA16_SNORM													= 0x9018, /** GL_ALPHA16_SNORM */
		LSI_KIF_GL_ALPHA16UI_EXT													= 0x8D78, /** GL_ALPHA16UI_EXT */
		LSI_KIF_GL_ALPHA16I_EXT														= 0x8D8A, /** GL_ALPHA16I_EXT */
		LSI_KIF_GL_ALPHA16F_ARB														= 0x881C, /** GL_ALPHA16F_ARB */
		LSI_KIF_GL_ALPHA32UI_EXT													= 0x8D72, /** GL_ALPHA32UI_EXT */
		LSI_KIF_GL_ALPHA32I_EXT														= 0x8D84, /** GL_ALPHA32I_EXT */
		LSI_KIF_GL_ALPHA32F_ARB														= 0x8816, /** GL_ALPHA32F_ARB */
		//
		// Luminance
		//
		LSI_KIF_GL_LUMINANCE4														= 0x803F, /** GL_LUMINANCE4 */
		LSI_KIF_GL_LUMINANCE8														= 0x8040, /** GL_LUMINANCE8 */
		LSI_KIF_GL_LUMINANCE8_SNORM													= 0x9015, /** GL_LUMINANCE8_SNORM */
		LSI_KIF_GL_SLUMINANCE8														= 0x8C47, /** GL_SLUMINANCE8 */
		LSI_KIF_GL_LUMINANCE8UI_EXT													= 0x8D80, /** GL_LUMINANCE8UI_EXT */
		LSI_KIF_GL_LUMINANCE8I_EXT													= 0x8D92, /** GL_LUMINANCE8I_EXT */
		LSI_KIF_GL_LUMINANCE12														= 0x8041, /** GL_LUMINANCE12 */
		LSI_KIF_GL_LUMINANCE16														= 0x8042, /** GL_LUMINANCE16 */
		LSI_KIF_GL_LUMINANCE16_SNORM												= 0x9019, /** GL_LUMINANCE16_SNORM */
		LSI_KIF_GL_LUMINANCE16UI_EXT												= 0x8D7A, /** GL_LUMINANCE16UI_EXT */
		LSI_KIF_GL_LUMINANCE16I_EXT													= 0x8D8C, /** GL_LUMINANCE16I_EXT */
		LSI_KIF_GL_LUMINANCE16F_ARB													= 0x881E, /** GL_LUMINANCE16F_ARB */
		LSI_KIF_GL_LUMINANCE32UI_EXT												= 0x8D74, /** GL_LUMINANCE32UI_EXT */
		LSI_KIF_GL_LUMINANCE32I_EXT													= 0x8D86, /** GL_LUMINANCE32I_EXT */
		LSI_KIF_GL_LUMINANCE32F_ARB													= 0x8818, /** GL_LUMINANCE32F_ARB */
		//
		// Luminance/Alpha
		//
		LSI_KIF_GL_LUMINANCE4_ALPHA4												= 0x8043, /** GL_LUMINANCE4_ALPHA4 */
		LSI_KIF_GL_LUMINANCE6_ALPHA2												= 0x8044, /** GL_LUMINANCE6_ALPHA2 */
		LSI_KIF_GL_LUMINANCE8_ALPHA8												= 0x8045, /** GL_LUMINANCE8_ALPHA8 */
		LSI_KIF_GL_LUMINANCE8_ALPHA8_SNORM											= 0x9016, /** GL_LUMINANCE8_ALPHA8_SNORM */
		LSI_KIF_GL_SLUMINANCE8_ALPHA8												= 0x8C45, /** GL_SLUMINANCE8_ALPHA8 */
		LSI_KIF_GL_LUMINANCE_ALPHA8UI_EXT											= 0x8D81, /** GL_LUMINANCE_ALPHA8UI_EXT */
		LSI_KIF_GL_LUMINANCE_ALPHA8I_EXT											= 0x8D93, /** GL_LUMINANCE_ALPHA8I_EXT */
		LSI_KIF_GL_LUMINANCE12_ALPHA4												= 0x8046, /** GL_LUMINANCE12_ALPHA4 */
		LSI_KIF_GL_LUMINANCE12_ALPHA12												= 0x8047, /** GL_LUMINANCE12_ALPHA12 */
		LSI_KIF_GL_LUMINANCE16_ALPHA16												= 0x8048, /** GL_LUMINANCE16_ALPHA16 */
		LSI_KIF_GL_LUMINANCE16_ALPHA16_SNORM										= 0x901A, /** GL_LUMINANCE16_ALPHA16_SNORM */
		LSI_KIF_GL_LUMINANCE_ALPHA16UI_EXT											= 0x8D7B, /** GL_LUMINANCE_ALPHA16UI_EXT */
		LSI_KIF_GL_LUMINANCE_ALPHA16I_EXT											= 0x8D8D, /** GL_LUMINANCE_ALPHA16I_EXT */
		LSI_KIF_GL_LUMINANCE_ALPHA16F_ARB											= 0x881F, /** GL_LUMINANCE_ALPHA16F_ARB */
		LSI_KIF_GL_LUMINANCE_ALPHA32UI_EXT											= 0x8D75, /** GL_LUMINANCE_ALPHA32UI_EXT */
		LSI_KIF_GL_LUMINANCE_ALPHA32I_EXT											= 0x8D87, /** GL_LUMINANCE_ALPHA32I_EXT */
		LSI_KIF_GL_LUMINANCE_ALPHA32F_ARB											= 0x8819, /** GL_LUMINANCE_ALPHA32F_ARB */
		//
		// Intensity
		//
		LSI_KIF_GL_INTENSITY4														= 0x804A, /** GL_INTENSITY4 */
		LSI_KIF_GL_INTENSITY8														= 0x804B, /** GL_INTENSITY8 */
		LSI_KIF_GL_INTENSITY8_SNORM													= 0x9017, /** GL_INTENSITY8_SNORM */
		LSI_KIF_GL_INTENSITY8UI_EXT													= 0x8D7F, /** GL_INTENSITY8UI_EXT */
		LSI_KIF_GL_INTENSITY8I_EXT													= 0x8D91, /** GL_INTENSITY8I_EXT */
		LSI_KIF_GL_INTENSITY12														= 0x804C, /** GL_INTENSITY12 */
		LSI_KIF_GL_INTENSITY16														= 0x804D, /** GL_INTENSITY16 */
		LSI_KIF_GL_INTENSITY16_SNORM												= 0x901B, /** GL_INTENSITY16_SNORM */
		LSI_KIF_GL_INTENSITY16UI_EXT												= 0x8D79, /** GL_INTENSITY16UI_EXT */
		LSI_KIF_GL_INTENSITY16I_EXT													= 0x8D8B, /** GL_INTENSITY16I_EXT */
		LSI_KIF_GL_INTENSITY16F_ARB													= 0x881D, /** GL_INTENSITY16F_ARB */
		LSI_KIF_GL_INTENSITY32UI_EXT												= 0x8D73, /** GL_INTENSITY32UI_EXT */
		LSI_KIF_GL_INTENSITY32I_EXT													= 0x8D85, /** GL_INTENSITY32I_EXT */
		LSI_KIF_GL_INTENSITY32F_ARB													= 0x8817, /** GL_INTENSITY32F_ARB */
		//
		// Generic compression
		//
		LSI_KIF_GL_COMPRESSED_RED													= 0x8225, /** GL_COMPRESSED_RED */
		LSI_KIF_GL_COMPRESSED_ALPHA													= 0x84E9, /** GL_COMPRESSED_ALPHA */
		LSI_KIF_GL_COMPRESSED_LUMINANCE												= 0x84EA, /** GL_COMPRESSED_LUMINANCE */
		LSI_KIF_GL_COMPRESSED_SLUMINANCE											= 0x8C4A, /** GL_COMPRESSED_SLUMINANCE */
		LSI_KIF_GL_COMPRESSED_LUMINANCE_ALPHA										= 0x84EB, /** GL_COMPRESSED_LUMINANCE_ALPHA */
		LSI_KIF_GL_COMPRESSED_SLUMINANCE_ALPHA										= 0x8C4B, /** GL_COMPRESSED_SLUMINANCE_ALPHA */
		LSI_KIF_GL_COMPRESSED_INTENSITY												= 0x84EC, /** GL_COMPRESSED_INTENSITY */
		LSI_KIF_GL_COMPRESSED_RG													= 0x8226, /** GL_COMPRESSED_RG */
		LSI_KIF_GL_COMPRESSED_RGB													= 0x84ED, /** GL_COMPRESSED_RGB */
		LSI_KIF_GL_COMPRESSED_RGBA													= 0x84EE, /** GL_COMPRESSED_RGBA */
		LSI_KIF_GL_COMPRESSED_SRGB													= 0x8C48, /** GL_COMPRESSED_SRGB */
		LSI_KIF_GL_COMPRESSED_SRGB_ALPHA											= 0x8C49, /** GL_COMPRESSED_SRGB_ALPHA */
		//
		// FXT1
		//
		LSI_KIF_GL_COMPRESSED_RGB_FXT1_3DFX											= 0x86B0, /** GL_COMPRESSED_RGB_FXT1_3DFX */
		LSI_KIF_GL_COMPRESSED_RGBA_FXT1_3DFX										= 0x86B1, /** GL_COMPRESSED_RGBA_FXT1_3DFX */
		//
		// S3TC/DXT/BC
		//
		LSI_KIF_GL_COMPRESSED_RGB_S3TC_DXT1_EXT										= 0x83F0, /** GL_COMPRESSED_RGB_S3TC_DXT1_EXT */
		LSI_KIF_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT									= 0x83F1, /** GL_COMPRESSED_RGBA_S3TC_DXT1_EXT */
		LSI_KIF_GL_COMPRESSED_RGBA_S3TC_DXT3_EXT									= 0x83F2, /** GL_COMPRESSED_RGBA_S3TC_DXT3_EXT */
		LSI_KIF_GL_COMPRESSED_RGBA_S3TC_DXT5_EXT									= 0x83F3, /** GL_COMPRESSED_RGBA_S3TC_DXT5_EXT */
		LSI_KIF_GL_COMPRESSED_SRGB_S3TC_DXT1_EXT									= 0x8C4C, /** GL_COMPRESSED_SRGB_S3TC_DXT1_EXT */
		LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT								= 0x8C4D, /** GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
		LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT								= 0x8C4E, /** GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
		LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT								= 0x8C4F, /** GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
		LSI_KIF_GL_COMPRESSED_LUMINANCE_LATC1_EXT									= 0x8C70, /** GL_COMPRESSED_LUMINANCE_LATC1_EXT */
		LSI_KIF_GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT								= 0x8C72, /** GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT */
		LSI_KIF_GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT							= 0x8C71, /** GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT */
		LSI_KIF_GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT						= 0x8C73, /** GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT */
		LSI_KIF_GL_COMPRESSED_RED_RGTC1												= 0x8DBB, /** GL_COMPRESSED_RED_RGTC1 */
		LSI_KIF_GL_COMPRESSED_RG_RGTC2												= 0x8DBD, /** GL_COMPRESSED_RG_RGTC2 */
		LSI_KIF_GL_COMPRESSED_SIGNED_RED_RGTC1										= 0x8DBC, /** GL_COMPRESSED_SIGNED_RED_RGTC1 */
		LSI_KIF_GL_COMPRESSED_SIGNED_RG_RGTC2										= 0x8DBE, /** GL_COMPRESSED_SIGNED_RG_RGTC2 */
		LSI_KIF_GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT									= 0x8E8E, /** GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT */
		LSI_KIF_GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT								= 0x8E8F, /** GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT */
		LSI_KIF_GL_COMPRESSED_RGBA_BPTC_UNORM										= 0x8E8C, /** GL_COMPRESSED_RGBA_BPTC_UNORM */
		LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM									= 0x8E8D, /** GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM */
		//
		// ETC
		//
		LSI_KIF_GL_ETC1_RGB8_OES													= 0x8D64, /** GL_ETC1_RGB8_OES */
		LSI_KIF_GL_COMPRESSED_RGB8_ETC2												= 0x9274, /** GL_COMPRESSED_RGB8_ETC2 */
		LSI_KIF_GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2							= 0x9276, /** GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
		LSI_KIF_GL_COMPRESSED_RGBA8_ETC2_EAC										= 0x9278, /** GL_COMPRESSED_RGBA8_ETC2_EAC */
		LSI_KIF_GL_COMPRESSED_SRGB8_ETC2											= 0x9275, /** GL_COMPRESSED_SRGB8_ETC2 */
		LSI_KIF_GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2						= 0x9277, /** GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC									= 0x9279, /** GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
		LSI_KIF_GL_COMPRESSED_R11_EAC												= 0x9270, /** GL_COMPRESSED_R11_EAC */
		LSI_KIF_GL_COMPRESSED_RG11_EAC												= 0x9272, /** GL_COMPRESSED_RG11_EAC */
		LSI_KIF_GL_COMPRESSED_SIGNED_R11_EAC										= 0x9271, /** GL_COMPRESSED_SIGNED_R11_EAC */
		LSI_KIF_GL_COMPRESSED_SIGNED_RG11_EAC										= 0x9273, /** GL_COMPRESSED_SIGNED_RG11_EAC */
		//
		// PVRTC
		//
		LSI_KIF_GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG									= 0x8C01, /** GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG */
		LSI_KIF_GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG									= 0x8C00, /** GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG */
		LSI_KIF_GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG									= 0x8C03, /** GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */
		LSI_KIF_GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG									= 0x8C02, /** GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */

		LSI_KIF_GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG									= 0x9137, /** GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG */
		LSI_KIF_GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG									= 0x9138, /** GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG */

		LSI_KIF_GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT									= 0x8A54, /** GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT */
		LSI_KIF_GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT									= 0x8A55, /** GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT */
		LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT							= 0x8A56, /** GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT */
		LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT							= 0x8A57, /** GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT */

		LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG							= 0x93F0, /** GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG */
		LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG							= 0x93F1, /** GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG */
		//
		// ASTC
		//
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_4x4_KHR										= 0x93B0, /** GL_COMPRESSED_RGBA_ASTC_4x4_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_5x4_KHR										= 0x93B1, /** GL_COMPRESSED_RGBA_ASTC_5x4_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_5x5_KHR										= 0x93B2, /** GL_COMPRESSED_RGBA_ASTC_5x5_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_6x5_KHR										= 0x93B3, /** GL_COMPRESSED_RGBA_ASTC_6x5_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_6x6_KHR										= 0x93B4, /** GL_COMPRESSED_RGBA_ASTC_6x6_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_8x5_KHR										= 0x93B5, /** GL_COMPRESSED_RGBA_ASTC_8x5_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_8x6_KHR										= 0x93B6, /** GL_COMPRESSED_RGBA_ASTC_8x6_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_8x8_KHR										= 0x93B7, /** GL_COMPRESSED_RGBA_ASTC_8x8_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_10x5_KHR									= 0x93B8, /** GL_COMPRESSED_RGBA_ASTC_10x5_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_10x6_KHR									= 0x93B9, /** GL_COMPRESSED_RGBA_ASTC_10x6_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_10x8_KHR									= 0x93BA, /** GL_COMPRESSED_RGBA_ASTC_10x8_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_10x10_KHR									= 0x93BB, /** GL_COMPRESSED_RGBA_ASTC_10x10_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_12x10_KHR									= 0x93BC, /** GL_COMPRESSED_RGBA_ASTC_12x10_KHR */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_12x12_KHR									= 0x93BD, /** GL_COMPRESSED_RGBA_ASTC_12x12_KHR */

		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR								= 0x93D0, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR								= 0x93D1, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR								= 0x93D2, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR								= 0x93D3, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR								= 0x93D4, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR								= 0x93D5, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR								= 0x93D6, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR								= 0x93D7, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR							= 0x93D8, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR							= 0x93D9, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR							= 0x93DA, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR							= 0x93DB, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR							= 0x93DC, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR							= 0x93DD, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */

		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_3x3x3_OES									= 0x93C0, /** GL_COMPRESSED_RGBA_ASTC_3x3x3_OES */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_4x3x3_OES									= 0x93C1, /** GL_COMPRESSED_RGBA_ASTC_4x3x3_OES */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_4x4x3_OES									= 0x93C2, /** GL_COMPRESSED_RGBA_ASTC_4x4x3_OES */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_4x4x4_OES									= 0x93C3, /** GL_COMPRESSED_RGBA_ASTC_4x4x4_OES */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_5x4x4_OES									= 0x93C4, /** GL_COMPRESSED_RGBA_ASTC_5x4x4_OES */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_5x5x4_OES									= 0x93C5, /** GL_COMPRESSED_RGBA_ASTC_5x5x4_OES */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_5x5x5_OES									= 0x93C6, /** GL_COMPRESSED_RGBA_ASTC_5x5x5_OES */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_6x5x5_OES									= 0x93C7, /** GL_COMPRESSED_RGBA_ASTC_6x5x5_OES */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_6x6x5_OES									= 0x93C8, /** GL_COMPRESSED_RGBA_ASTC_6x6x5_OES */
		LSI_KIF_GL_COMPRESSED_RGBA_ASTC_6x6x6_OES									= 0x93C9, /** GL_COMPRESSED_RGBA_ASTC_6x6x6_OES */

		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES							= 0x93E0, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES							= 0x93E1, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES							= 0x93E2, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES							= 0x93E3, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES							= 0x93E4, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES							= 0x93E5, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES							= 0x93E6, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES							= 0x93E7, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES							= 0x93E8, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES */
		LSI_KIF_GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES							= 0x93E9, /** GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES */
		//
		// ATC
		//
		LSI_KIF_GL_ATC_RGB_AMD														= 0x8C92, /** GL_ATC_RGB_AMD */
		LSI_KIF_GL_ATC_RGBA_EXPLICIT_ALPHA_AMD										= 0x8C93, /** GL_ATC_RGBA_EXPLICIT_ALPHA_AMD */
		LSI_KIF_GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD									= 0x87EE, /** GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD */
		//
		// Palletized (combined palette)
		//
		LSI_KIF_GL_PALETTE4_RGB8_OES												= 0x8B90, /** GL_PALETTE4_RGB8_OES */
		LSI_KIF_GL_PALETTE4_RGBA8_OES												= 0x8B91, /** GL_PALETTE4_RGBA8_OES */
		LSI_KIF_GL_PALETTE4_R5_G6_B5_OES											= 0x8B92, /** GL_PALETTE4_R5_G6_B5_OES */
		LSI_KIF_GL_PALETTE4_RGBA4_OES												= 0x8B93, /** GL_PALETTE4_RGBA4_OES */
		LSI_KIF_GL_PALETTE4_RGB5_A1_OES												= 0x8B94, /** GL_PALETTE4_RGB5_A1_OES */
		LSI_KIF_GL_PALETTE8_RGB8_OES												= 0x8B95, /** GL_PALETTE8_RGB8_OES */
		LSI_KIF_GL_PALETTE8_RGBA8_OES												= 0x8B96, /** GL_PALETTE8_RGBA8_OES */
		LSI_KIF_GL_PALETTE8_R5_G6_B5_OES											= 0x8B97, /** GL_PALETTE8_R5_G6_B5_OES */
		LSI_KIF_GL_PALETTE8_RGBA4_OES												= 0x8B98, /** GL_PALETTE8_RGBA4_OES */
		LSI_KIF_GL_PALETTE8_RGB5_A1_OES												= 0x8B99, /** GL_PALETTE8_RGB5_A1_OES */
		//
		// Palletized (separate palette)
		//
		LSI_KIF_GL_COLOR_INDEX1_EXT													= 0x80E2, /** GL_COLOR_INDEX1_EXT */
		LSI_KIF_GL_COLOR_INDEX2_EXT													= 0x80E3, /** GL_COLOR_INDEX2_EXT */
		LSI_KIF_GL_COLOR_INDEX4_EXT													= 0x80E4, /** GL_COLOR_INDEX4_EXT */
		LSI_KIF_GL_COLOR_INDEX8_EXT													= 0x80E5, /** GL_COLOR_INDEX8_EXT */
		LSI_KIF_GL_COLOR_INDEX12_EXT												= 0x80E6, /** GL_COLOR_INDEX12_EXT */
		LSI_KIF_GL_COLOR_INDEX16_EXT												= 0x80E7, /** GL_COLOR_INDEX16_EXT */
		//
		// Depth/stencil
		//
		LSI_KIF_GL_DEPTH_COMPONENT16												= 0x81A5, /** GL_DEPTH_COMPONENT16 */
		LSI_KIF_GL_DEPTH_COMPONENT24												= 0x81A6, /** GL_DEPTH_COMPONENT24 */
		LSI_KIF_GL_DEPTH_COMPONENT32												= 0x81A7, /** GL_DEPTH_COMPONENT32 */
		LSI_KIF_GL_DEPTH_COMPONENT32F												= 0x8CAC, /** GL_DEPTH_COMPONENT32F */
		LSI_KIF_GL_DEPTH_COMPONENT32F_NV											= 0x8DAB, /** GL_DEPTH_COMPONENT32F_NV */
		LSI_KIF_GL_STENCIL_INDEX1													= 0x8D46, /** GL_STENCIL_INDEX1 */
		LSI_KIF_GL_STENCIL_INDEX4													= 0x8D47, /** GL_STENCIL_INDEX4 */
		LSI_KIF_GL_STENCIL_INDEX8													= 0x8D48, /** GL_STENCIL_INDEX8 */
		LSI_KIF_GL_STENCIL_INDEX16													= 0x8D49, /** GL_STENCIL_INDEX16 */
		LSI_KIF_GL_DEPTH24_STENCIL8													= 0x88F0, /** GL_DEPTH24_STENCIL8 */
		LSI_KIF_GL_DEPTH32F_STENCIL8												= 0x8CAD, /** GL_DEPTH32F_STENCIL8 */
		LSI_KIF_GL_DEPTH32F_STENCIL8_NV												= 0x8DAC, /** GL_DEPTH32F_STENCIL8_NV */
	};

	/**
	 * glBaseInternalFormat values.  Table 8.11 of OpenGL 4.4.
	 */
	enum LSI_KTX_BASE_INTERNAL_FORMAT : uint16_t {
		LSI_KBIF_GL_RED																= 0x1903, /** GL_RED */
		LSI_KBIF_GL_GREEN															= 0x1904, /** GL_GREEN */
		LSI_KBIF_GL_BLUE															= 0x1905, /** GL_BLUE */
		LSI_KBIF_GL_ALPHA															= 0x1906, /** GL_ALPHA */
		LSI_KBIF_GL_LUMINANCE														= 0x1909, /** GL_LUMINANCE */
		LSI_KBIF_GL_SLUMINANCE														= 0x8C46, /** GL_SLUMINANCE */
		LSI_KBIF_GL_LUMINANCE_ALPHA													= 0x190A, /** GL_LUMINANCE_ALPHA */
		LSI_KBIF_GL_SLUMINANCE_ALPHA												= 0x8C44, /** GL_SLUMINANCE_ALPHA */
		LSI_KBIF_GL_INTENSITY														= 0x8049, /** GL_INTENSITY */
		LSI_KBIF_GL_RG																= 0x8227, /** GL_RG */
		LSI_KBIF_GL_RGB																= 0x1907, /** GL_RGB */
		LSI_KBIF_GL_BGR																= 0x80E0, /** GL_BGR */
		LSI_KBIF_GL_RGBA															= 0x1908, /** GL_RGBA */
		LSI_KBIF_GL_BGRA															= 0x80E1, /** GL_BGRA */
		LSI_KBIF_GL_RED_INTEGER														= 0x8D94, /** GL_RED_INTEGER */
		LSI_KBIF_GL_GREEN_INTEGER													= 0x8D95, /** GL_GREEN_INTEGER */
		LSI_KBIF_GL_BLUE_INTEGER													= 0x8D96, /** GL_BLUE_INTEGER */
		LSI_KBIF_GL_ALPHA_INTEGER													= 0x8D97, /** GL_ALPHA_INTEGER */
		LSI_KBIF_GL_LUMINANCE_INTEGER												= 0x8D9C, /** GL_LUMINANCE_INTEGER */
		LSI_KBIF_GL_LUMINANCE_ALPHA_INTEGER											= 0x8D9D, /** GL_LUMINANCE_ALPHA_INTEGER */
		LSI_KBIF_GL_RG_INTEGER														= 0x8228, /** GL_RG_INTEGER */
		LSI_KBIF_GL_RGB_INTEGER														= 0x8D98, /** GL_RGB_INTEGER */
		LSI_KBIF_GL_BGR_INTEGER														= 0x8D9A, /** GL_BGR_INTEGER */
		LSI_KBIF_GL_RGBA_INTEGER													= 0x8D99, /** GL_RGBA_INTEGER */
		LSI_KBIF_GL_BGRA_INTEGER													= 0x8D9B, /** GL_BGRA_INTEGER */
		LSI_KBIF_GL_COLOR_INDEX														= 0x1900, /** GL_COLOR_INDEX */
		LSI_KBIF_GL_STENCIL_INDEX													= 0x1901, /** GL_STENCIL_INDEX */
		LSI_KBIF_GL_DEPTH_COMPONENT													= 0x1902, /** GL_DEPTH_COMPONENT */
		LSI_KBIF_GL_DEPTH_STENCIL													= 0x84F9, /** GL_DEPTH_STENCIL */
		LSI_KBIF_0																	= 0,
	};

	/**
	 * VkFormat values.
	 */
	enum LSI_VKFORMAT : int32_t {
		LSI_VK_FORMAT_UNDEFINED = 0,
		LSI_VK_FORMAT_R4G4_UNORM_PACK8 = 1,
		LSI_VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
		LSI_VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
		LSI_VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
		LSI_VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
		LSI_VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
		LSI_VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
		LSI_VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
		LSI_VK_FORMAT_R8_UNORM = 9,
		LSI_VK_FORMAT_R8_SNORM = 10,
		LSI_VK_FORMAT_R8_USCALED = 11,
		LSI_VK_FORMAT_R8_SSCALED = 12,
		LSI_VK_FORMAT_R8_UINT = 13,
		LSI_VK_FORMAT_R8_SINT = 14,
		LSI_VK_FORMAT_R8_SRGB = 15,
		LSI_VK_FORMAT_R8G8_UNORM = 16,
		LSI_VK_FORMAT_R8G8_SNORM = 17,
		LSI_VK_FORMAT_R8G8_USCALED = 18,
		LSI_VK_FORMAT_R8G8_SSCALED = 19,
		LSI_VK_FORMAT_R8G8_UINT = 20,
		LSI_VK_FORMAT_R8G8_SINT = 21,
		LSI_VK_FORMAT_R8G8_SRGB = 22,
		LSI_VK_FORMAT_R8G8B8_UNORM = 23,
		LSI_VK_FORMAT_R8G8B8_SNORM = 24,
		LSI_VK_FORMAT_R8G8B8_USCALED = 25,
		LSI_VK_FORMAT_R8G8B8_SSCALED = 26,
		LSI_VK_FORMAT_R8G8B8_UINT = 27,
		LSI_VK_FORMAT_R8G8B8_SINT = 28,
		LSI_VK_FORMAT_R8G8B8_SRGB = 29,
		LSI_VK_FORMAT_B8G8R8_UNORM = 30,
		LSI_VK_FORMAT_B8G8R8_SNORM = 31,
		LSI_VK_FORMAT_B8G8R8_USCALED = 32,
		LSI_VK_FORMAT_B8G8R8_SSCALED = 33,
		LSI_VK_FORMAT_B8G8R8_UINT = 34,
		LSI_VK_FORMAT_B8G8R8_SINT = 35,
		LSI_VK_FORMAT_B8G8R8_SRGB = 36,
		LSI_VK_FORMAT_R8G8B8A8_UNORM = 37,
		LSI_VK_FORMAT_R8G8B8A8_SNORM = 38,
		LSI_VK_FORMAT_R8G8B8A8_USCALED = 39,
		LSI_VK_FORMAT_R8G8B8A8_SSCALED = 40,
		LSI_VK_FORMAT_R8G8B8A8_UINT = 41,
		LSI_VK_FORMAT_R8G8B8A8_SINT = 42,
		LSI_VK_FORMAT_R8G8B8A8_SRGB = 43,
		LSI_VK_FORMAT_B8G8R8A8_UNORM = 44,
		LSI_VK_FORMAT_B8G8R8A8_SNORM = 45,
		LSI_VK_FORMAT_B8G8R8A8_USCALED = 46,
		LSI_VK_FORMAT_B8G8R8A8_SSCALED = 47,
		LSI_VK_FORMAT_B8G8R8A8_UINT = 48,
		LSI_VK_FORMAT_B8G8R8A8_SINT = 49,
		LSI_VK_FORMAT_B8G8R8A8_SRGB = 50,
		LSI_VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
		LSI_VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
		LSI_VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
		LSI_VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
		LSI_VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
		LSI_VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
		LSI_VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
		LSI_VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
		LSI_VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
		LSI_VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
		LSI_VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
		LSI_VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
		LSI_VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
		LSI_VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
		LSI_VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
		LSI_VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
		LSI_VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
		LSI_VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
		LSI_VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
		LSI_VK_FORMAT_R16_UNORM = 70,
		LSI_VK_FORMAT_R16_SNORM = 71,
		LSI_VK_FORMAT_R16_USCALED = 72,
		LSI_VK_FORMAT_R16_SSCALED = 73,
		LSI_VK_FORMAT_R16_UINT = 74,
		LSI_VK_FORMAT_R16_SINT = 75,
		LSI_VK_FORMAT_R16_SFLOAT = 76,
		LSI_VK_FORMAT_R16G16_UNORM = 77,
		LSI_VK_FORMAT_R16G16_SNORM = 78,
		LSI_VK_FORMAT_R16G16_USCALED = 79,
		LSI_VK_FORMAT_R16G16_SSCALED = 80,
		LSI_VK_FORMAT_R16G16_UINT = 81,
		LSI_VK_FORMAT_R16G16_SINT = 82,
		LSI_VK_FORMAT_R16G16_SFLOAT = 83,
		LSI_VK_FORMAT_R16G16B16_UNORM = 84,
		LSI_VK_FORMAT_R16G16B16_SNORM = 85,
		LSI_VK_FORMAT_R16G16B16_USCALED = 86,
		LSI_VK_FORMAT_R16G16B16_SSCALED = 87,
		LSI_VK_FORMAT_R16G16B16_UINT = 88,
		LSI_VK_FORMAT_R16G16B16_SINT = 89,
		LSI_VK_FORMAT_R16G16B16_SFLOAT = 90,
		LSI_VK_FORMAT_R16G16B16A16_UNORM = 91,
		LSI_VK_FORMAT_R16G16B16A16_SNORM = 92,
		LSI_VK_FORMAT_R16G16B16A16_USCALED = 93,
		LSI_VK_FORMAT_R16G16B16A16_SSCALED = 94,
		LSI_VK_FORMAT_R16G16B16A16_UINT = 95,
		LSI_VK_FORMAT_R16G16B16A16_SINT = 96,
		LSI_VK_FORMAT_R16G16B16A16_SFLOAT = 97,
		LSI_VK_FORMAT_R32_UINT = 98,
		LSI_VK_FORMAT_R32_SINT = 99,
		LSI_VK_FORMAT_R32_SFLOAT = 100,
		LSI_VK_FORMAT_R32G32_UINT = 101,
		LSI_VK_FORMAT_R32G32_SINT = 102,
		LSI_VK_FORMAT_R32G32_SFLOAT = 103,
		LSI_VK_FORMAT_R32G32B32_UINT = 104,
		LSI_VK_FORMAT_R32G32B32_SINT = 105,
		LSI_VK_FORMAT_R32G32B32_SFLOAT = 106,
		LSI_VK_FORMAT_R32G32B32A32_UINT = 107,
		LSI_VK_FORMAT_R32G32B32A32_SINT = 108,
		LSI_VK_FORMAT_R32G32B32A32_SFLOAT = 109,
		LSI_VK_FORMAT_R64_UINT = 110,
		LSI_VK_FORMAT_R64_SINT = 111,
		LSI_VK_FORMAT_R64_SFLOAT = 112,
		LSI_VK_FORMAT_R64G64_UINT = 113,
		LSI_VK_FORMAT_R64G64_SINT = 114,
		LSI_VK_FORMAT_R64G64_SFLOAT = 115,
		LSI_VK_FORMAT_R64G64B64_UINT = 116,
		LSI_VK_FORMAT_R64G64B64_SINT = 117,
		LSI_VK_FORMAT_R64G64B64_SFLOAT = 118,
		LSI_VK_FORMAT_R64G64B64A64_UINT = 119,
		LSI_VK_FORMAT_R64G64B64A64_SINT = 120,
		LSI_VK_FORMAT_R64G64B64A64_SFLOAT = 121,
		LSI_VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
		LSI_VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
		LSI_VK_FORMAT_D16_UNORM = 124,
		LSI_VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
		LSI_VK_FORMAT_D32_SFLOAT = 126,
		LSI_VK_FORMAT_S8_UINT = 127,
		LSI_VK_FORMAT_D16_UNORM_S8_UINT = 128,
		LSI_VK_FORMAT_D24_UNORM_S8_UINT = 129,
		LSI_VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
		LSI_VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
		LSI_VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
		LSI_VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
		LSI_VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
		LSI_VK_FORMAT_BC2_UNORM_BLOCK = 135,
		LSI_VK_FORMAT_BC2_SRGB_BLOCK = 136,
		LSI_VK_FORMAT_BC3_UNORM_BLOCK = 137,
		LSI_VK_FORMAT_BC3_SRGB_BLOCK = 138,
		LSI_VK_FORMAT_BC4_UNORM_BLOCK = 139,
		LSI_VK_FORMAT_BC4_SNORM_BLOCK = 140,
		LSI_VK_FORMAT_BC5_UNORM_BLOCK = 141,
		LSI_VK_FORMAT_BC5_SNORM_BLOCK = 142,
		LSI_VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
		LSI_VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
		LSI_VK_FORMAT_BC7_UNORM_BLOCK = 145,
		LSI_VK_FORMAT_BC7_SRGB_BLOCK = 146,
		LSI_VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
		LSI_VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
		LSI_VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
		LSI_VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
		LSI_VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
		LSI_VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
		LSI_VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
		LSI_VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
		LSI_VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
		LSI_VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
		LSI_VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
		LSI_VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
		LSI_VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
		LSI_VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
		LSI_VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
		LSI_VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
		LSI_VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
		LSI_VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
		LSI_VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
		LSI_VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
		LSI_VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
		LSI_VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
		LSI_VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
		LSI_VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
		LSI_VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
		LSI_VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
		LSI_VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
		LSI_VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
		LSI_VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
		LSI_VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
		LSI_VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
		LSI_VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
		LSI_VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
		LSI_VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
		LSI_VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
		LSI_VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
		LSI_VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
		LSI_VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
		LSI_VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
		LSI_VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
		LSI_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
		LSI_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
		LSI_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
		LSI_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
		LSI_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
		LSI_VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
		LSI_VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
		LSI_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
		LSI_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
		LSI_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
		LSI_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
		LSI_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
		LSI_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
		LSI_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
		LSI_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
		LSI_VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
		LSI_VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
		LSI_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
		LSI_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
		LSI_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
		LSI_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
		LSI_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
		LSI_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
		LSI_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
		LSI_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
		LSI_VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
		LSI_VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
		LSI_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
		LSI_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
		LSI_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
		LSI_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
		LSI_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
		LSI_VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
		LSI_VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
		LSI_VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
		LSI_VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
		LSI_VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
		LSI_VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
		LSI_VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
		LSI_VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
		LSI_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
		LSI_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
		LSI_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
		LSI_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
		LSI_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
		LSI_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
		LSI_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
		LSI_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
		LSI_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
		LSI_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
		LSI_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
		LSI_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
		LSI_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
		LSI_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,
		LSI_VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT = 1000288000,
		LSI_VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT = 1000288001,
		LSI_VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT = 1000288002,
		LSI_VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT = 1000288003,
		LSI_VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT = 1000288004,
		LSI_VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT = 1000288005,
		LSI_VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT = 1000288006,
		LSI_VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT = 1000288007,
		LSI_VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT = 1000288008,
		LSI_VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT = 1000288009,
		LSI_VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT = 1000288010,
		LSI_VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT = 1000288011,
		LSI_VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT = 1000288012,
		LSI_VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT = 1000288013,
		LSI_VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT = 1000288014,
		LSI_VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT = 1000288015,
		LSI_VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT = 1000288016,
		LSI_VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT = 1000288017,
		LSI_VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT = 1000288018,
		LSI_VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT = 1000288019,
		LSI_VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT = 1000288020,
		LSI_VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT = 1000288021,
		LSI_VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT = 1000288022,
		LSI_VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT = 1000288023,
		LSI_VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT = 1000288024,
		LSI_VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT = 1000288025,
		LSI_VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT = 1000288026,
		LSI_VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT = 1000288027,
		LSI_VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT = 1000288028,
		LSI_VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT = 1000288029,
		LSI_VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000,
		LSI_VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001,
		LSI_VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
	};

	/**
	 * Class CKtx
	 * \brief Handles loading of .KTX files.
	 *
	 * Description: Handles loading of .KTX files.
	 */
	class CKtx {
	public :
		// == Types.
		/** The compression-size calculator. */
		typedef uint32_t					(LSE_CALL * PfCompSizeFunc)( uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Factor );

		/** Function type for converting from any LSI_KTX_INTERNAL_FORMAT to RGBA32F. */
		typedef bool						(LSE_CALL * PfToRgba32F)( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms );

		/** Function type for converting from RGBA32F to an LSI_KTX_INTERNAL_FORMATformat. */
		typedef bool						(LSE_CALL * PfFromRgba32F)( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms );

		/** The KTX header. */
#pragma pack( push, 1 )
		typedef struct LSI_KTX_HEADER {
			uint8_t							ui8Identifier[12];
			uint32_t						ui32Endienness;
			uint32_t						ui32GlType;
			uint32_t						ui32GlTypeSize;
			uint32_t						ui32GlFormat;
			uint32_t						ui32GlInternalFormat;
			uint32_t						ui32GlBaseInternalFormat;
			uint32_t						ui32PixelWidth;
			uint32_t						ui32PixelHeight;
			uint32_t						ui32PixelDepth;
			uint32_t						ui32NumberofArrayElements;
			uint32_t						ui32NumberofFaces;
			uint32_t						ui32NumberofMipmapLevels;
			uint32_t						ui32BytesOfKeyValueData;
		} * LPLSI_KTX_HEADER, * const LPCLSI_KTX_HEADER;

		/** Extended header. */
		typedef struct LSI_KTX_KEY_VALUE_PAIR {
			uint32_t						ui32KeyAndValueByteSize;
			uint8_t							ui8KeyAndValue[4];
		} * LPLSI_KTX_KEY_VALUE_PAIR, * const LPCLSI_KTX_KEY_VALUE_PAIR;
#pragma pack( pop )

#if 0
		/** Internal format data. */
		typedef struct LSI_KTX_INTERNAL_FORMAT_DATA {
			/** The format identifier. */
			LSI_KTX_INTERNAL_FORMAT			kifInternalFormat;
			/** The OpenGL name of the identifier. */
			const char *					pcName;
			/** The internal base format. */
			LSI_KTX_BASE_INTERNAL_FORMAT	kbifBaseInternalFormat;
			/** The size of each texel/block. */
			uint32_t						ui32TexelOrBlockSize;
			/** Is it compressed? */
			bool							bCompressed;
			/** Is it a palette type? */
			bool							bPalette;
			/** Is it sRGB? */
			bool							bSrgb;
			/** Function for getting its compressed size. */
			PfCompSizeFunc					pfCompSizeFunc;
		} * LPLSI_KTX_INTERNAL_FORMAT_DATA, * const LPCLSI_KTX_INTERNAL_FORMAT_DATA;
#else

		/** Internal format data. */
		typedef struct LSI_KTX_INTERNAL_FORMAT_DATA {
			/** The format identifier. */
			LSI_KTX_INTERNAL_FORMAT			kifInternalFormat;
			/** The type. */
			LSI_KTX_TYPE					ktType;
			/** The internal base format. */
			LSI_KTX_BASE_INTERNAL_FORMAT	kbifBaseInternalFormat;
			/** KTX flags. */
			uint32_t						ui32Flags;
			/** Palette size in bits. */
			uint32_t						ui32PaletteSizeInBits;
			/** Block size in bits. */
			uint32_t						ui32BlockSizeInBits;
			/** Block width. */
			uint32_t						ui32BlockWidth;
			/** Block height. */
			uint32_t						ui32BlockHeight;
			/** Block depth. */
			uint32_t						ui32BlockDepth;
			/** Minimum blocks X. */
			uint32_t						ui32MinBlocksX;
			/** Minimum blocks Y. */
			uint32_t						ui32MinBlocksY;
			/** Is it sRGB? */
			bool							bSrgb;
			/** Is it compressed? */
			bool							bCompressed;
			/** Is it a palette type? */
			bool							bPalette;
			/** Function for getting its compressed size. */
			PfCompSizeFunc					pfCompSizeFunc;
			/** Function to convert to RGBA32F. */
			PfToRgba32F						pfToRgba32F;
			/** Function to convert from RGBA32F to the internal OpenGL/Vulkan format. */
			PfFromRgba32F					pfFromRgba32F;
		} * LPLSI_KTX_INTERNAL_FORMAT_DATA, * const LPCLSI_KTX_INTERNAL_FORMAT_DATA;
#endif	// 0

		// == Functions.
		/**
		 * Loads a KTX 1 file from memory.
		 *
		 * \param _pui8FileData The in-memory image of the file.
		 * \param _ui32DataLen The length of the in-memory image of the file.
		 * \param _ui32Width The returned width of the image.
		 * \param _ui32Height The returned height of the image.
		 * \param _pfFormat Indicates the format of the converted data held in _tbReturn.
		 * \param _ktGlType The OpenGL type of the image.
		 * \param _kfFormat The OpenGL format of the image.
		 * \param _kifInternalFormat The OpenGL internal format of the image.
		 * \param _kbifInternalBaseFormat The OpenGL internal base format of the image.
		 * \param _tbReturn The returned data.
		 * \param _vMipMaps The returned mipmap data, if any.
		 * \return Returns true if the file was successfully loaded.  False indicates an invalid file or lack of RAM.
		 */
		static LSBOOL LSE_CALL				LoadKtx1( const uint8_t * _pui8FileData, uint32_t _ui32DataLen,
			uint32_t &_ui32Width, uint32_t &_ui32Height, LSI_PIXEL_FORMAT &_pfFormat,
			LSI_KTX_TYPE &_ktGlType, LSI_KTX_FORMAT &_kfFormat, LSI_KTX_INTERNAL_FORMAT &_kifInternalFormat, LSI_KTX_BASE_INTERNAL_FORMAT &_kbifInternalBaseFormat,
			CImageLib::CTexelBuffer &_tbReturn,
			CVector<CImageLib::CTexelBuffer> &_vMipMaps );

		/**
		 * Loads a KTX 2 file from memory.
		 *
		 * \param _pui8FileData The in-memory image of the file.
		 * \param _ui32DataLen The length of the in-memory image of the file.
		 * \param _ui32Width The returned width of the image.
		 * \param _ui32Height The returned height of the image.
		 * \param _pfFormat Indicates the format of the converted data held in _tbReturn.
		 * \param _vfFormatnternalBaseFormat The Vulkan format of the image.
		 * \param _tbReturn The returned data.
		 * \param _vMipMaps The returned mipmap data, if any.
		 * \return Returns true if the file was successfully loaded.  False indicates an invalid file or lack of RAM.
		 */
		static LSBOOL LSE_CALL				LoadKtx2( const uint8_t * _pui8FileData, uint32_t _ui32DataLen,
			uint32_t &_ui32Width, uint32_t &_ui32Height, LSI_PIXEL_FORMAT &_pfFormat,
			LSI_VKFORMAT &_vfFormatnternalBaseFormat,
			CImageLib::CTexelBuffer &_tbReturn,
			CVector<CImageLib::CTexelBuffer> &_vMipMaps );

		/**
		 * Finds the details for a given internal format.
		 *
		 * \param _kifInternalFormat The OpenGL internal format whose details are to be found.
		 * \return Returns the details for the given internal format or nullptr.
		 */
		static const LSI_KTX_INTERNAL_FORMAT_DATA * LSE_CALL
											FindInternalFormatData( LSI_KTX_INTERNAL_FORMAT _kifInternalFormat );

		/**
		 * Gets an internal format entry by index.
		 *
		 * \param _stIndex Index of the entry to obtain.
		 * \return Returns nullptr if the entry index is out of bounds, otherwise the requested entry.
		 */
		static const LSI_KTX_INTERNAL_FORMAT_DATA * LSE_CALL
											GetInternalFormatData( size_t _stIndex );

		/**
		 * Gets the total entries in the internal format data list.
		 *
		 * \return Returns the total entries in the internal format data list.
		 */
		static size_t LSE_CALL				GetInternalFormatDataTotal();

		/**
		 * Returns the total size of a compressed image given a factor and its width and height.
		 *
		 * \param _ui32Width Width in pixels.
		 * \param _ui32Height Height in pixels.
		 * \param _ui32Factor Multiplier.
		 * \return Returns the size of the compressed data.
		 */
		static uint32_t LSE_CALL			GetCompressedSize( uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Factor );

		/**
		 * Returns the total size of an ASTC image given a factor and its width and height.
		 *
		 * \param _ui32Width Width in pixels.
		 * \param _ui32Height Height in pixels.
		 * \param _ui32Factor Multiplier.
		 * \return Returns the size of the compressed data.
		 */
		template <unsigned uL, unsigned uR>
		static uint32_t LSE_CALL			GetCompressedSizeAstc( uint32_t _ui32Width, uint32_t _ui32Height, uint32_t /*_ui32Factor*/ ) {
			return ((_ui32Width + (uL - 1)) / uL) * ((_ui32Height + (uR - 1)) / uR) * 16;
		}

		/**
		 * Returns the total size of a PVRTC image given a factor and its width and height.
		 *
		 * \param _ui32Width Width in pixels.
		 * \param _ui32Height Height in pixels.
		 * \param _ui32Factor Multiplier.
		 * \return Returns the size of the compressed data.
		 */
		template <unsigned uL, unsigned uR>
		static uint32_t LSE_CALL			GetCompressedSizePvrtc( uint32_t _ui32Width, uint32_t _ui32Height, uint32_t /*_ui32Factor*/ ) {
			return ((_ui32Width + (uL - 1)) / uL) * ((_ui32Height + (uR - 1)) / uR) * 8;
		}

		/**
		 * Returns the size of a texture of the given width, height, and depth based off its LSI_KTX_INTERNAL_FORMAT_DATA representation.
		 *
		 * \param _ui32Width Width in pixels.
		 * \param _ui32Height Height in pixels.
		 * \param _ui32Depth Depth in pixels.
		 * \param _pkifdData Format descriptor.
		 * \return Returns the size in bytes needed for the texture data.
		 */
		static uint32_t LSE_CALL			GetTextureSize( uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, const LSI_KTX_INTERNAL_FORMAT_DATA * _pkifdData );

#ifndef LSI_USE_KHRONOS
		/**
		 * Given an image format, return the OpenGL internal format for standard textures.
		 *
		 * \param _pfFormat Format to convert.
		 * \param _bsRgb If true, an sRGB format is selected, if possible.
		 * \return Returns the OpenGL internal format to use with the given image-library format.
		 */
		static LSE_INLINE int32_t LSE_CALL	GetOpenGlInternalFormatStandard( LSI_PIXEL_FORMAT _pfFormat, LSBOOL _bsRgb = false );

		/**
		 * Given an image format, return the OpenGL format for standard textures.
		 *
		 * \param _pfFormat Format to convert.
		 * \return Returns the OpenGL format to use with the given image-library format.
		 */
		static LSE_INLINE uint32_t LSE_CALL	GetOpenGlFormatStandard( LSI_PIXEL_FORMAT _pfFormat );

		/**
		 * Given an image format, return the OpenGL type for standard textures.
		 *
		 * \param _pfFormat Format to convert.
		 * \return Returns the OpenGL type to use with the given image-library format.
		 */
		static LSE_INLINE uint32_t LSE_CALL	GetOpenGlTypeStandard( LSI_PIXEL_FORMAT _pfFormat );
#endif	// #ifndef LSI_USE_KHRONOS

		/**
		 * Converts a LSI_KTX_TYPE value to a string.
		 *
		 * \param _tType The type to convert to a string.
		 * \return Returns the string form of a given LSI_KTX_TYPE value.
		 */
		static const char * LSE_CALL		glTypeToString( LSI_KTX_TYPE _tType );

		/**
		 * Converts a LSI_KTX_FORMAT value to a string.
		 *
		 * \param _fFormat The format to convert to a string.
		 * \return Returns the string form of a given LSI_KTX_FORMAT value.
		 */
		static const char * LSE_CALL		glFormatToString( LSI_KTX_FORMAT _fFormat );

		/**
		 * Converts a LSI_KTX_INTERNAL_FORMAT value to a string.
		 *
		 * \param _ifInternalFormat The type to convert to a string.
		 * \return Returns the string form of a given LSI_KTX_INTERNAL_FORMAT value.
		 */
		static const char * LSE_CALL		glInternalFormatToString( LSI_KTX_INTERNAL_FORMAT _ifInternalFormat );

		/**
		 * Converts a LSI_KTX_BASE_INTERNAL_FORMAT value to a string.
		 *
		 * \param _bifBaseInternalFormat The type to convert to a string.
		 * \return Returns the string form of a given LSI_KTX_BASE_INTERNAL_FORMAT value.
		 */
		static const char * LSE_CALL		glBaseInternalFormatToString( LSI_KTX_BASE_INTERNAL_FORMAT _bifBaseInternalFormat );

		/**
		 * Gets the size of _ktType in bytes.
		 *
		 * \param _ktType The type whose size is to be returned.
		 * \return the size of _ktType in bytes.
		 */
		static uint32_t LSE_CALL			glTypeToSize( LSI_KTX_TYPE _ktType );

#ifdef LSI_PRINT_TABLE
		/**
		 * TMP
		 */
		static void							PrintTable();
#endif	// #ifdef LSI_PRINT_TABLE

	protected :
		// == Types.
#ifdef LSI_USE_KHRONOS
		typedef struct LSI_KTX_IMAGE_LOAD {
			CImageLib::CTexelBuffer *		ptbReturn;
			CVector<CImageLib::CTexelBuffer> *
											pvMipMaps;
		} * LPLSI_KTX_IMAGE_LOAD, * const LPCLSI_KTX_IMAGE_LOAD;
#endif	// LSI_USE_KHRONOS


		// == Members.
		/** The data for internal formats. */
		static const LSI_KTX_INTERNAL_FORMAT_DATA
											m_kifdInternalFormats[];


		// == Functions.
#ifdef LSI_USE_KHRONOS
		/**
		 * Callback to load each face's data from a KTX file.
		 *
		 * \param _iMipLevel Mipmap level, starting from 0.
		 * \param _iFace_ Face index, usually 0, or 0-5 for cube maps.
		 * \param _iWidth Width of the image.
		 * \param _iHeight Height of the image.
		 * \param _iDepth Depth of the image.
		 * \param _ui64FaceLodSize Number of bytes to which _pvPixels points.
		 * \param _pvPixels The actual texture data.
		 * \param _pvUserdata User data passed to the callback for its own use.
		 * \return Returns an error code to indicate failure or success.
		 */
		static KTX_error_code				KtxImageLoad( int _iMipLevel, int _iFace_,
			int _iWidth, int _iHeight, int _iDepth,
			ktx_uint64_t _ui64FaceLodSize,
			void * _pvPixels, void * _pvUserdata );
#endif	// LSI_USE_KHRONOS

		/**
		 * Generic conversion of a single integer component to a float (normalized).
		 *
		 * \param _ui64Value The RGBA texel.
		 * \param _fDefault The default value to return if there are no bits for the component within _ui64Value (_uBits is 0).
		 * \return Returns the component extracted from _ui64Value and converted to a float.
		 */
		template <unsigned _uBits, unsigned _uShift, unsigned _uSigned, unsigned _bSrgb>
		static LSE_INLINE float LSE_CALL	StdIntComponentTo32F_Norm( uint64_t _ui64Value, float _fDefault ) {
			if ( _uBits != 0 ) {
				if ( _uSigned != 0 ) {
					const uint64_t ui64Mask = (1ULL << _uBits) - 1ULL;
					int64_t i64Texel = ((_ui64Value >> _uShift) & ui64Mask);
					// Sign-extend.
					i64Texel <<= 64ULL - _uBits;
					i64Texel >>= 64ULL - _uBits;
					// warning C4293: '<<': shift count negative or too big, undefined behavior
					//	_uBits can't be 0 so this warning is invalid.
					// warning C4723: potential divide by 0
					//	_uBits can't be 0 so this warning is invalid.
					float fFinal = CStd::Clamp<float>( i64Texel / static_cast<float>((1ULL << (_uBits - 1ULL)) - 1ULL), -1.0, 1.0 );
					return _bSrgb ? CImageLib::SRgbToLinear( fFinal ) : fFinal;
				}
				else {
					const uint64_t ui64Max = (1ULL << _uBits) - 1ULL;
					float fFinal = ((_ui64Value >> _uShift) & ui64Max) / static_cast<float>(ui64Max);
					return _bSrgb ? CImageLib::SRgbToLinear( fFinal ) : fFinal; 
				}
			}
			else { return _fDefault; }
		}

		/**
		 * Generic conversion of a single floating-point value to a single normalized RGBA component encoded inside a uint64_t.  The appropriate bits
		 *	inside the uint64_t value are cleared and then overwritten, modifying only the bits that correspend to the texel component being
		 *	updated.
		 *
		 * \param _fValue The value to convert.
		 * \param _ui64Value The RGBA texel to update.
		 */
		template <unsigned _uBits, unsigned _uShift, unsigned _uSigned, unsigned _bSrgb>
		static LSE_INLINE void LSE_CALL		Std32FToIntComponent_Norm( float _fValue, uint64_t &_ui64Value ) {
			// Only do something if there are actual bits to modify.
			if ( _uBits != 0 ) {
				if ( _bSrgb != 0 ) {
					_fValue = CImageLib::LinearToSRgb( _fValue );
				}
				// Clear the target bits.
				const uint64_t ui64Mask = (1ULL << _uBits) - 1ULL;
				_ui64Value = _ui64Value & ~(ui64Mask << _uShift);
				if ( _uSigned != 0 ) {
					int64_t i64Val = static_cast<int64_t>(std::round( CStd::Clamp( _fValue, -1.0f, 1.0f ) * static_cast<float>((1ULL << (_uBits - 1ULL)) - 1ULL) ));
					_ui64Value |= (i64Val & ui64Mask) << _uShift;
				}
				else {
					uint64_t ui64Val = static_cast<uint64_t>(std::round( CStd::Clamp( _fValue, 0.0f, 1.0f ) * ui64Mask ));
					_ui64Value |= (ui64Val & ui64Mask) << _uShift;
				}
			}
		}

		/**
		 * Generic conversion of a single integer component to a float (not normalized).
		 *
		 * \param _ui64Value The RGBA texel.
		 * \param _fDefault The default value to return if there are no bits for the component within _ui64Value (_uBits is 0).
		 * \return Returns the component extracted from _ui64Value and converted to a float.
		 */
		template <unsigned _uBits, unsigned _uShift, unsigned _uSigned>
		static LSE_INLINE float LSE_CALL	StdIntComponentTo32F( uint64_t _ui64Value, float _fDefault ) {
			if ( _uBits != 0 ) {
				if ( _uSigned != 0 ) {
					const uint64_t ui64Mask = (1ULL << _uBits) - 1ULL;
					int64_t i64Texel = ((_ui64Value >> _uShift) & ui64Mask);
					// Sign-extend.
					i64Texel <<= 64ULL - _uBits;
					i64Texel >>= _uBits;
					// warning C4293: '<<': shift count negative or too big, undefined behavior
					//	_uBits can't be 0 so this warning is invalid.
					// warning C4723: potential divide by 0
					//	_uBits can't be 0 so this warning is invalid.
					return static_cast<float>(i64Texel);
				}
				else {
					const uint64_t ui64Max = (1ULL << _uBits) - 1ULL;
					return static_cast<float>((_ui64Value >> _uShift) & ui64Max);
				}
			}
			else { return _fDefault; }
		}

		/**
		 * Generic conversion of a single floating-point value to a single non-normalized RGBA component encoded inside a uint64_t.  The appropriate bits
		 *	inside the uint64_t value are cleared and then overwritten, modifying only the bits that correspend to the texel component being
		 *	updated.
		 *
		 * \param _fValue The value to convert.
		 * \param _ui64Value The RGBA texel to update.
		 */
		template <unsigned _uBits, unsigned _uShift, unsigned _uSigned>
		static LSE_INLINE void LSE_CALL		Std32FToIntComponent( float _fValue, uint64_t &_ui64Value ) {
			// Only do something if there are actual bits to modify.
			if ( _uBits != 0 ) {
				// Clear the target bits.
				const uint64_t ui64Mask = (1ULL << _uBits) - 1ULL;
				_ui64Value = _ui64Value & ~(ui64Mask << _uShift);
				if ( _uSigned != 0 ) {
					int64_t i64Val = static_cast<int64_t>(std::round( CStd::Clamp( _fValue, -std::powf( 2.0f, _uBits - 1.0f ), std::powf( 2.0f, _uBits - 1.0f ) - 1.0f ) ));
					_ui64Value |= (i64Val & ui64Mask) << _uShift;
				}
				else {
					uint64_t ui64Val = static_cast<uint64_t>(std::round( CStd::Clamp( _fValue, 0.0f, std::powf( 2.0f, _uBits ) - 1.0f ) ));
					_ui64Value |= (ui64Val & ui64Mask) << _uShift;
				}
			}
		}

		/**
		 * Returns the maximum of 3 components.
		 *
		 * \param _fR The R component.
		 * \param _fG The G component.
		 * \param _fB The B component.
		 * \return Returns the maximum of 3 components.
		 */
		static LSE_INLINE float LSE_CALL	Max( float _fR, float _fG, float _fB ) {
			if ( _fR > _fG ) {
				if ( _fR > _fB ) { return _fR; }
				else { return _fB; }
			}
			else {
				if ( _fG > _fB ) { return _fG; }
				else { return _fB; }
			}
		}

		/**
		 * Clamps a value within RGB9_E5 range
		 *
		 * \param _fVal The value to clamp.
		 * \return Returns _fVal clamped between 0.0f and LSI_MAX_RGB9E5.
		 */
		static LSE_INLINE float LSE_CALL	ClampRangeRgb9e5( float _fVal ) {
			return CStd::Clamp( _fVal, 0.0f, LSI_MAX_RGB9E5 );
		}

		/**
		 * Gets the biased exponent from a floating-point number.
		 *
		 * \param _fVal The value whose exponent is to be retrieved.
		 * \return Returns the biased exponent from a floating-point number.
		 */
		static LSE_INLINE int32_t LSE_CALL	FloorLog2( float _fVal ) {
			struct LSI_FLOAT {
				uint32_t ui32Mantissa : 23;
				uint32_t ui32BiasedExponent : 8;
				uint32_t ui32Negative : 1;
			};
			union LSI_FLOAT_754 {
				LSI_FLOAT	fField;
				float		fValue;
			};
			LSI_FLOAT_754 fFTmp;

			fFTmp.fValue = _fVal;
			return (fFTmp.fField.ui32BiasedExponent - 127);
}

		/**
		 * Converts a single RGB9_E5 texel into an RGBA32F texel.
		 *
		 * \param _ui32R The RGB9_E5 R component.
		 * \param _ui32G The RGB9_E5 G component.
		 * \param _ui32B The RGB9_E5 B component.
		 * \param _ui32E The RGB9_E5 E component.
		 * \param _pfDst The destination floats for decoding.
		 */
		static LSE_INLINE void LSE_CALL		DecodeRgb9_E5( uint32_t _ui32R, uint32_t _ui32G, uint32_t _ui32B, uint32_t _ui32E, float * _pfDst ) {
			int32_t i32Exp = _ui32E - LSI_RGB9E5_EXP_BIAS - LSI_RGB9E5_MANTISSA_BITS;
			float fScale = std::powf( 2.0f, float( i32Exp ) );

			_pfDst[LSI_PC_R] = _ui32R * fScale;
			_pfDst[LSI_PC_G] = _ui32G * fScale;
			_pfDst[LSI_PC_B] = _ui32B * fScale;
			_pfDst[LSI_PC_A] = 1.0;
		}

		/**
		 * Converts a single RGBA32F texel to an RGB9_E5 texel.
		 *
		 * \param _ui32Rgb9E5 The output texel encoded in a uint32_t value.
		 * \param _pfSrc The source floats.
		 */
		static LSE_INLINE void LSE_CALL		EncodeRgb9_E5( uint32_t &_ui32Rgb9E5, const float * _pfSrc ) {
			float fR = ClampRangeRgb9e5( _pfSrc[LSI_PC_R] );
			float fG = ClampRangeRgb9e5( _pfSrc[LSI_PC_G] );
			float fB = ClampRangeRgb9e5( _pfSrc[LSI_PC_B] );
			float fMax = Max( fR, fG, fB );
			int32_t i32ExpShared = static_cast<int32_t>(CStd::Max( -LSI_RGB9E5_EXP_BIAS - 1, FloorLog2( fMax ) ) + 1 + LSI_RGB9E5_EXP_BIAS);
			float fDenom = std::powf( 2.0f, float( i32ExpShared - LSI_RGB9E5_EXP_BIAS - LSI_RGB9E5_MANTISSA_BITS ) );

			int32_t i32MaxM = static_cast<int32_t>(std::floor( fMax / fDenom + 0.5f ));
			if ( i32MaxM == LSI_MAX_RGB9E5_MANTISSA + 1 ) {
				fDenom *= 2.0f;
				++i32ExpShared;
			}

			int32_t i32Rm = static_cast<int32_t>(std::floor( fR / fDenom + 0.5f ));
			int32_t i32Gm = static_cast<int32_t>(std::floor( fG / fDenom + 0.5f ));
			int32_t i32Bm = static_cast<int32_t>(std::floor( fB / fDenom + 0.5f ));

			struct LSI_RGB9E5 {
				uint32_t ui32R : LSI_RGB9E5_MANTISSA_BITS;
				uint32_t ui32G : LSI_RGB9E5_MANTISSA_BITS;
				uint32_t ui32B : LSI_RGB9E5_MANTISSA_BITS;
				uint32_t ui32E : LSI_RGB9E5_EXPONENT_BITS;
			};
			LSI_RGB9E5 * prDst = reinterpret_cast<LSI_RGB9E5 *>(&_ui32Rgb9E5);
			prDst->ui32R = i32Rm;
			prDst->ui32G = i32Gm;
			prDst->ui32B = i32Bm;
			prDst->ui32E = i32ExpShared;
		}

		/**
		 * Generic integer format -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool LSE_CALL				StdIntToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Generic RGBA32F -> integer format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool LSE_CALL				StdIntFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * 128-bit integer format -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool LSE_CALL				Int128ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> 128-bit integer format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool LSE_CALL				Int128FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * float16 -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool LSE_CALL				F16ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> float16 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool LSE_CALL				F16FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * float32 -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool LSE_CALL				F32ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> float32 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
			unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool LSE_CALL				F32FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * R11G11B10F -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static LSE_INLINE bool LSE_CALL		R11G11B10FToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> R11G11B10F conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static LSE_INLINE bool LSE_CALL		R11G11B10FFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGB9E5 -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static LSE_INLINE bool LSE_CALL		RGB9E5ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> RGB9E5 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static LSE_INLINE bool LSE_CALL		RGB9E5FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Luminance/alpha format -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uLBits, unsigned _uABits,
			unsigned _uLShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool LSE_CALL				LumAlphaToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Generic RGBA32F -> luminance/alpha format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uLBits, unsigned _uABits,
			unsigned _uLShift, unsigned _uAShift,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
		static bool LSE_CALL				LumAlphaFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Luminance/alpha (floating-point) format -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uLBits, unsigned _uABits,
			unsigned _uLShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool LSE_CALL				LumAlphaFToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Generic RGBA32F -> luminance/alpha (floating-point) format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uLBits, unsigned _uABits,
			unsigned _uLShift, unsigned _uAShift,
			unsigned _uTexelSize>
		static bool LSE_CALL				LumAlphaFFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Intensity format -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uIBits,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bFloat>
		static bool LSE_CALL				IntensityToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Generic RGBA32F -> intensity format conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template <unsigned _uIBits,
			unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bFloat>
		static bool LSE_CALL				IntensityFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Depth-16 -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth16ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> Depth-16 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth16FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Depth-24 -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth24ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> Depth-24 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth24FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Depth-32 -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth32ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> Depth-32 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth32FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Depth-32F -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth32FToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> Depth-32F conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth32FFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Depth-24/Stencil-8 -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth24S8ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> Depth-24/Stencil-8 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth24S8FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Depth-32F/Stencil-8 -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth32FS8ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> Depth-32F/Stencil-8 conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		static bool LSE_CALL				Depth32FS8FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * Stencil-X -> RGBA32F conversion.
		 *
		 * \param _pui8Src Source texels.
		 * \param _pui8Dst Destination texels known to be in RGBA32F format.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template<typename _tType, unsigned _uBits>
		static bool LSE_CALL				StencilXToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

		/**
		 * RGBA32F -> Stencil-X conversion.
		 *
		 * \param _pui8Src Source texels known to be in RGBA32F format.
		 * \param _pui8Dst Destination texels.
		 * \param _ui32Width Width of the image.
		 * \param _ui32Height Height of the image.
		 * \param _ui32Depth Depth of the image.
		 * \param _pvParms Optional parameters for the conversion.
		 */
		template<typename _tType, unsigned _uBits>
		static bool LSE_CALL				StencilXFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * _pvParms = nullptr );

	};

	// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	// DEFINITIONS
	// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	// == Functions.
#ifndef LSI_USE_KHRONOS
	/**
	 * Given an image format, return the OpenGL internal format for standard textures.
	 *
	 * \param _pfFormat Format to convert.
	 * \param _bsRgb If true, an sRGB format is selected, if possible.
	 * \return Returns the OpenGL internal format to use with the given image-library format.
	 */
	LSE_INLINE int32_t LSE_CALL CKtx::GetOpenGlInternalFormatStandard( LSI_PIXEL_FORMAT _pfFormat, LSBOOL _bsRgb ) {
#if 0
		if ( _bsRgb ) {
			if ( _pfFormat >= LSI_PF_DTX_START && _pfFormat < LSI_PF_DTX_END ) {
				static const int32_t iInternalFormatssRgb[] = {
					LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,			// LSI_PF_DXT1
					LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
					LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,			// LSI_PF_DXT3
					LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
					LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,			// LSI_PF_DXT5
					0,												// LSI_PF_BC4/LSI_PF_BC4U
					0,												// LSI_PF_BC4S
					0,												// LSI_PF_BC5/LSI_PF_BC5U
					0,												// LSI_PF_BC5S
					0,												// LSI_PF_BC6/LSI_PF_BC6U
					0,												// LSI_PF_BC6S
					0,												// LSI_PF_BC7/LSI_PF_BC7U
					LSI_KIF_GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM,			// LSI_PF_BC7_SRGB
				};

				return iInternalFormatssRgb[_pfFormat-LSI_PF_DXT1];
			}
			static const int32_t iFormatssRgb[] = {
				LSI_KIF_GL_ALPHA,				// LSI_PF_A8
				0,						// LSI_PF_R3G3B2
				0,						// LSI_PF_R5G6B5
				0,						// LSI_PF_R4G4B4A4
				0,						// LSI_PF_R5G5B5A1
				LSI_KIF_GL_SRGB8,				// LSI_PF_R8G8B8
				LSI_KIF_GL_SRGB8_ALPHA8,		// LSI_PF_R8G8B8A8
				0,						// LSI_PF_R16G16B16A16
				0,						// LSI_PF_R16G16B16A16F
				0,						// LSI_PF_R32G32B32A32F
			};
			if ( _pfFormat >= LSI_PF_A8 && _pfFormat <= LSI_PF_R32G32B32A32F ) { return iFormatssRgb[_pfFormat]; }
		}
		else {
			if ( _pfFormat >= LSI_PF_DTX_START && _pfFormat < LSI_PF_DTX_END ) {
				static const int32_t iInternalFormats[] = {
					LSI_KIF_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,				// LSI_PF_DXT1
					LSI_KIF_GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
					LSI_KIF_GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,				// LSI_PF_DXT3
					LSI_KIF_GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,
					LSI_KIF_GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,				// LSI_PF_DXT5
					LSI_KIF_GL_COMPRESSED_RED_RGTC1,						// LSI_PF_BC4/LSI_PF_BC4U
					LSI_KIF_GL_COMPRESSED_SIGNED_RED_RGTC1,					// LSI_PF_BC4S
					LSI_KIF_GL_COMPRESSED_RG_RGTC2,							// LSI_PF_BC5/LSI_PF_BC5U
					LSI_KIF_GL_COMPRESSED_SIGNED_RG_RGTC2,					// LSI_PF_BC5S
					LSI_KIF_GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT,			// LSI_PF_BC6/LSI_PF_BC6U
					LSI_KIF_GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT,			// LSI_PF_BC6S
					LSI_KIF_GL_COMPRESSED_RGBA_BPTC_UNORM,					// LSI_PF_BC7/LSI_PF_BC7U
					0,												// LSI_PF_BC7_SRGB
				};
				return iInternalFormats[_pfFormat-LSI_PF_DXT1];
			}
			static const int32_t iFormats[] = {
				LSI_KIF_GL_ALPHA,				// LSI_PF_A8
				LSI_KIF_GL_RGB,					// LSI_PF_R3G3B2
				LSI_KIF_GL_RGB,					// LSI_PF_R5G6B5
				LSI_KIF_GL_RGBA,				// LSI_PF_R4G4B4A4
				LSI_KIF_GL_RGBA,				// LSI_PF_R5G5B5A1
				LSI_KIF_GL_RGB,					// LSI_PF_R8G8B8
				LSI_KIF_GL_RGBA,				// LSI_PF_R8G8B8A8
				LSI_KIF_GL_RGBA16,				// LSI_PF_R16G16B16A16
				LSI_KIF_GL_RGBA16F,				// LSI_PF_R16G16B16A16F
				LSI_KIF_GL_RGBA32F,				// LSI_PF_R32G32B32A32F
			};
			if ( _pfFormat >= LSI_PF_A8 && _pfFormat <= LSI_PF_R32G32B32A32F ) { return iFormats[_pfFormat]; }
		}
#endif
		// For compressed textures, return 0.
		return 0;
	}

	/**
	 * Given an image format, return the OpenGL format for standard textures.
	 *
	 * \param _pfFormat Format to convert.
	 * \return Returns the OpenGL format to use with the given image-library format.
	 */
	LSE_INLINE uint32_t LSE_CALL CKtx::GetOpenGlFormatStandard( LSI_PIXEL_FORMAT _pfFormat ) {
		static const int32_t iFormats[] = {
			LSI_KF_GL_ALPHA,				// LSI_PF_A8
			LSI_KF_GL_RGB,					// LSI_PF_R3G3B2
			LSI_KF_GL_RGB,					// LSI_PF_R5G6B5
			LSI_KF_GL_RGBA,					// LSI_PF_R4G4B4A4
			LSI_KF_GL_RGBA,					// LSI_PF_R5G5B5A1
			LSI_KF_GL_BGR,					// LSI_PF_R8G8B8
			LSI_KF_GL_RGBA,					// LSI_PF_R8G8B8A8
			LSI_KF_GL_RGBA,					// LSI_PF_R16G16B16A16
			LSI_KF_GL_RGBA,					// LSI_PF_R16G16B16A16F
			LSI_KF_GL_RGBA,					// LSI_PF_R32G32B32A32F
		};
		if ( _pfFormat >= LSI_PF_A8 && _pfFormat <= LSI_PF_R32G32B32A32F ) { return iFormats[_pfFormat]; }
		// For compressed textures, return 0.
		return 0;
	}

	/**
	 * Given an image format, return the OpenGL type for standard textures.
	 *
	 * \param _pfFormat Format to convert.
	 * \return Returns the OpenGL type to use with the given image-library format.
	 */
	LSE_INLINE uint32_t LSE_CALL CKtx::GetOpenGlTypeStandard( LSI_PIXEL_FORMAT _pfFormat ) {
		static const int32_t iTypes[] = {
			LSI_KT_GL_UNSIGNED_BYTE,						// LSI_PF_A8
			LSI_KT_GL_UNSIGNED_BYTE_3_3_2,					// LSI_PF_R3G3B2
			LSI_KT_GL_UNSIGNED_SHORT_5_6_5,					// LSI_PF_R5G6B5
			LSI_KT_GL_UNSIGNED_SHORT_4_4_4_4,				// LSI_PF_R4G4B4A4
			LSI_KT_GL_UNSIGNED_SHORT_5_5_5_1,				// LSI_PF_R5G5B5A1
			LSI_KT_GL_UNSIGNED_BYTE,						// LSI_PF_R8G8B8
			LSI_KT_GL_UNSIGNED_INT_8_8_8_8,					// LSI_PF_R8G8B8A8
			LSI_KT_GL_UNSIGNED_SHORT,						// LSI_PF_R16G16B16A16
			LSI_KT_GL_HALF_FLOAT,							// LSI_PF_R16G16B16A16F
			LSI_KT_GL_FLOAT,								// LSI_PF_R32G32B32A32F
		};
		if ( _pfFormat >= LSI_PF_A8 && _pfFormat <= LSI_PF_R32G32B32A32F ) { return iTypes[_pfFormat]; }
		// For compressed textures, return 0.
		return 0;
	}
#endif	// #ifndef LSI_USE_KHRONOS

	/**
	 * Generic integer format -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool LSE_CALL CKtx::StdIntToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					const uint64_t * pui64Src = reinterpret_cast<const uint64_t *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.fTexel[LSI_PC_R] = _bNorm ? StdIntComponentTo32F_Norm<_uRBits, _uRShift, _bSigned, _bSrgb>( (*pui64Src), 0.0f ) : StdIntComponentTo32F<_uRBits, _uRShift, _bSigned>( (*pui64Src), 0.0f );
					rgbaThis.fTexel[LSI_PC_G] = _bNorm ? StdIntComponentTo32F_Norm<_uGBits, _uGShift, _bSigned, _bSrgb>( (*pui64Src), 0.0f ) : StdIntComponentTo32F<_uGBits, _uGShift, _bSigned>( (*pui64Src), 0.0f );
					rgbaThis.fTexel[LSI_PC_B] = _bNorm ? StdIntComponentTo32F_Norm<_uBBits, _uBShift, _bSigned, _bSrgb>( (*pui64Src), 0.0f ) : StdIntComponentTo32F<_uBBits, _uBShift, _bSigned>( (*pui64Src), 0.0f );
					rgbaThis.fTexel[LSI_PC_A] = _bNorm ? StdIntComponentTo32F_Norm<_uABits, _uAShift, _bSigned, false>( (*pui64Src), 1.0f ) : StdIntComponentTo32F<_uABits, _uAShift, _bSigned>( (*pui64Src), 1.0f );
				}
			}
		}
		return true;
	}

	/**
	 * Generic RGBA32F -> integer format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool LSE_CALL CKtx::StdIntFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);
					uint64_t * pui64Dst = reinterpret_cast<uint64_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					if ( _bNorm ) { Std32FToIntComponent_Norm<_uRBits, _uRShift, _bSigned, _bSrgb>( rgbaThis.fTexel[LSI_PC_R], (*pui64Dst) ); }
					else { Std32FToIntComponent<_uRBits, _uRShift, _bSigned>( rgbaThis.fTexel[LSI_PC_R], (*pui64Dst) ); }
					if ( _bNorm ) { Std32FToIntComponent_Norm<_uGBits, _uGShift, _bSigned, _bSrgb>( rgbaThis.fTexel[LSI_PC_G], (*pui64Dst) ); }
					else { Std32FToIntComponent<_uGBits, _uGShift, _bSigned>( rgbaThis.fTexel[LSI_PC_G], (*pui64Dst) ); }
					if ( _bNorm ) { Std32FToIntComponent_Norm<_uBBits, _uBShift, _bSigned, _bSrgb>( rgbaThis.fTexel[LSI_PC_B], (*pui64Dst) ); }
					else { Std32FToIntComponent<_uBBits, _uBShift, _bSigned>( rgbaThis.fTexel[LSI_PC_B], (*pui64Dst) ); }
					if ( _bNorm ) { Std32FToIntComponent_Norm<_uABits, _uAShift, _bSigned, false>( rgbaThis.fTexel[LSI_PC_A], (*pui64Dst) ); }
					else { Std32FToIntComponent<_uABits, _uAShift, _bSigned>( rgbaThis.fTexel[LSI_PC_A], (*pui64Dst) ); }
				}
			}
		}
		return true;
	}

	/**
	 * 128-bit integer format -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool LSE_CALL CKtx::Int128ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		//__int128
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					const uint8_t * pui8Src = reinterpret_cast<const uint8_t *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.fTexel[LSI_PC_R] = _bNorm ? StdIntComponentTo32F_Norm<_uRBits, 0, _bSigned, _bSrgb>( reinterpret_cast<const uint64_t &>(pui8Src[_uRShift/8]), 0.0f ) : StdIntComponentTo32F<_uRBits, 0, _bSigned>( reinterpret_cast<const uint64_t &>(pui8Src[_uRShift/8]), 0.0f );
					rgbaThis.fTexel[LSI_PC_G] = _bNorm ? StdIntComponentTo32F_Norm<_uGBits, 0, _bSigned, _bSrgb>( reinterpret_cast<const uint64_t &>(pui8Src[_uGShift/8]), 0.0f ) : StdIntComponentTo32F<_uGBits, 0, _bSigned>( reinterpret_cast<const uint64_t &>(pui8Src[_uGShift/8]), 0.0f );
					rgbaThis.fTexel[LSI_PC_B] = _bNorm ? StdIntComponentTo32F_Norm<_uBBits, 0, _bSigned, _bSrgb>( reinterpret_cast<const uint64_t &>(pui8Src[_uBShift/8]), 0.0f ) : StdIntComponentTo32F<_uBBits, 0, _bSigned>( reinterpret_cast<const uint64_t &>(pui8Src[_uBShift/8]), 0.0f );
					rgbaThis.fTexel[LSI_PC_A] = _bNorm ? StdIntComponentTo32F_Norm<_uABits, 0, _bSigned, false>( reinterpret_cast<const uint64_t &>(pui8Src[_uAShift/8]), 1.0f ) : StdIntComponentTo32F<_uABits, 0, _bSigned>( reinterpret_cast<const uint64_t &>(pui8Src[_uAShift/8]), 1.0f );
				}
			}
		}
		return true;
	}

	/**
	 * RGBA32F -> 128-bit integer format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool LSE_CALL CKtx::Int128FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);
					uint8_t * pui8Dst = reinterpret_cast<uint8_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);

					if ( _bNorm ) { Std32FToIntComponent_Norm<_uRBits, 0, _bSigned, _bSrgb>( rgbaThis.fTexel[LSI_PC_R], reinterpret_cast<uint64_t &>(pui8Dst[_uRShift/8]) ); }
					else { Std32FToIntComponent<_uRBits, 0, _bSigned>( rgbaThis.fTexel[LSI_PC_R], reinterpret_cast<uint64_t &>(pui8Dst[_uRShift/8]) ); }
					if ( _bNorm ) { Std32FToIntComponent_Norm<_uGBits, 0, _bSigned, _bSrgb>( rgbaThis.fTexel[LSI_PC_G], reinterpret_cast<uint64_t &>(pui8Dst[_uGShift/8]) ); }
					else { Std32FToIntComponent<_uGBits, 0, _bSigned>( rgbaThis.fTexel[LSI_PC_G], reinterpret_cast<uint64_t &>(pui8Dst[_uGShift/8]) ); }
					if ( _bNorm ) { Std32FToIntComponent_Norm<_uBBits, 0, _bSigned, _bSrgb>( rgbaThis.fTexel[LSI_PC_B], reinterpret_cast<uint64_t &>(pui8Dst[_uBShift/8]) ); }
					else { Std32FToIntComponent<_uBBits, 0, _bSigned>( rgbaThis.fTexel[LSI_PC_B], reinterpret_cast<uint64_t &>(pui8Dst[_uBShift/8]) ); }
					if ( _bNorm ) { Std32FToIntComponent_Norm<_uABits, 0, _bSigned, false>( rgbaThis.fTexel[LSI_PC_A], reinterpret_cast<uint64_t &>(pui8Dst[_uAShift/8]) ); }
					else { Std32FToIntComponent<_uABits, 0, _bSigned>( rgbaThis.fTexel[LSI_PC_A], reinterpret_cast<uint64_t &>(pui8Dst[_uAShift/8]) ); }
				}
			}
		}
		return true;
	}

	/**
	 * float16 -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool LSE_CALL CKtx::F16ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					const CFloat16 * pf16Src = reinterpret_cast<const CFloat16 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.fTexel[LSI_PC_R] = _uRBits ? pf16Src[_uRShift/16] : 0.0f;
					rgbaThis.fTexel[LSI_PC_G] = _uGBits ? pf16Src[_uGShift/16] : 0.0f;
					rgbaThis.fTexel[LSI_PC_B] = _uBBits ? pf16Src[_uBShift/16] : 0.0f;
					rgbaThis.fTexel[LSI_PC_A] = _uABits ? pf16Src[_uAShift/16] : 1.0f;
				}
			}
		}
		return true;
	}

	/**
	 * RGBA32F -> float16 conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool LSE_CALL CKtx::F16FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);
					CFloat16 * pf16Dst = reinterpret_cast<CFloat16 *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					if ( _uRBits ) { pf16Dst[_uRShift/16] = rgbaThis.fTexel[LSI_PC_R]; }
					if ( _uGBits ) { pf16Dst[_uGShift/16] = rgbaThis.fTexel[LSI_PC_G]; }
					if ( _uBBits ) { pf16Dst[_uBShift/16] = rgbaThis.fTexel[LSI_PC_B]; }
					if ( _uABits ) { pf16Dst[_uAShift/16] = rgbaThis.fTexel[LSI_PC_A]; }
				}
			}
		}
		return true;
	}

	/**
	 * float32 -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool LSE_CALL CKtx::F32ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					const float * pf16Src = reinterpret_cast<const float *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					rgbaThis.fTexel[LSI_PC_R] = _uRBits ? pf16Src[_uRShift/32] : 0.0f;
					rgbaThis.fTexel[LSI_PC_G] = _uGBits ? pf16Src[_uGShift/32] : 0.0f;
					rgbaThis.fTexel[LSI_PC_B] = _uBBits ? pf16Src[_uBShift/32] : 0.0f;
					rgbaThis.fTexel[LSI_PC_A] = _uABits ? pf16Src[_uAShift/32] : 1.0f;
				}
			}
		}
		return true;
	}

	/**
	 * RGBA32F -> float32 conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uRBits, unsigned _uGBits, unsigned _uBBits, unsigned _uABits,
		unsigned _uRShift, unsigned _uGShift, unsigned _uBShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool LSE_CALL CKtx::F32FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);
					float * pf32Dst = reinterpret_cast<float *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					if ( _uRBits ) { pf32Dst[_uRShift/32] = rgbaThis.fTexel[LSI_PC_R]; }
					if ( _uGBits ) { pf32Dst[_uGShift/32] = rgbaThis.fTexel[LSI_PC_G]; }
					if ( _uBBits ) { pf32Dst[_uBShift/32] = rgbaThis.fTexel[LSI_PC_B]; }
					if ( _uABits ) { pf32Dst[_uAShift/32] = rgbaThis.fTexel[LSI_PC_A]; }
				}
			}
		}
		return true;
	}

	/**
	 * R11G11B10F -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	LSE_INLINE bool LSE_CALL CKtx::R11G11B10FToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		struct LSI_R11G11B10F {
			uint32_t ui32R : 11;
			uint32_t ui32G : 11;
			uint32_t ui32B : 10;
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( 4ULL * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					const LSI_R11G11B10F * prSrc = reinterpret_cast<const LSI_R11G11B10F *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*4ULL]);
					CFloatX fTemp;
					rgbaThis.fTexel[LSI_PC_R] = static_cast<float>(fTemp.CreateFromBits( prSrc->ui32R, LSI_FLOAT11 ).AsDouble());
					rgbaThis.fTexel[LSI_PC_G] = static_cast<float>(fTemp.CreateFromBits( prSrc->ui32G, LSI_FLOAT11 ).AsDouble());
					rgbaThis.fTexel[LSI_PC_B] = static_cast<float>(fTemp.CreateFromBits( prSrc->ui32B, LSI_FLOAT10 ).AsDouble());
					rgbaThis.fTexel[LSI_PC_A] = 1.0f;
				}
			}
		}
		return true;
	}

	/**
	 * RGBA32F -> R11G11B10F conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	LSE_INLINE bool LSE_CALL CKtx::R11G11B10FFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		struct LSI_R11G11B10F {
			uint32_t ui32R : 11;
			uint32_t ui32G : 11;
			uint32_t ui32B : 10;
		};
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( 4ULL * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);
					LSI_R11G11B10F * prDst = reinterpret_cast<LSI_R11G11B10F *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*4ULL]);
					CFloatX fTemp;
					prDst->ui32R = fTemp.CreateFromDouble( rgbaThis.fTexel[LSI_PC_R], LSI_FLOAT11 ).AsUint64();
					prDst->ui32G = fTemp.CreateFromDouble( rgbaThis.fTexel[LSI_PC_G], LSI_FLOAT11 ).AsUint64();
					prDst->ui32B = fTemp.CreateFromDouble( rgbaThis.fTexel[LSI_PC_B], LSI_FLOAT10 ).AsUint64();
				}
			}
		}
		return true;
	}

	/**
	 * RGB9E5 -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	LSE_INLINE bool LSE_CALL CKtx::RGB9E5ToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		struct LSI_RGB9E5 {
			uint32_t ui32R : LSI_RGB9E5_MANTISSA_BITS;
			uint32_t ui32G : LSI_RGB9E5_MANTISSA_BITS;
			uint32_t ui32B : LSI_RGB9E5_MANTISSA_BITS;
			uint32_t ui32E : LSI_RGB9E5_EXPONENT_BITS;
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( 4ULL * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					const LSI_RGB9E5 * prSrc = reinterpret_cast<const LSI_RGB9E5 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*4ULL]);
					DecodeRgb9_E5( prSrc->ui32R, prSrc->ui32G, prSrc->ui32B, prSrc->ui32E, rgbaThis.fTexel );
				}
			}
		}
		return true;
	}

	/**
	 * RGBA32F -> RGB9E5 conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	LSE_INLINE bool LSE_CALL CKtx::RGB9E5FromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( 4ULL * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);
					uint32_t * pui32Dst = reinterpret_cast<uint32_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*4ULL]);
					EncodeRgb9_E5( (*pui32Dst), rgbaThis.fTexel );
				}
			}
		}
		return true;
	}

	/**
	 * Luminance/alpha format -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uLBits, unsigned _uABits,
		unsigned _uLShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool LSE_CALL CKtx::LumAlphaToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					const uint64_t * pui64Src = reinterpret_cast<const uint64_t *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
					float fLum = _bNorm ? StdIntComponentTo32F_Norm<_uLBits, _uLShift, _bSigned, _bSrgb>( (*pui64Src), 0.0f ) : StdIntComponentTo32F<_uLBits, _uLShift, _bSigned>( (*pui64Src), 0.0f );
					rgbaThis.fTexel[LSI_PC_R] = fLum / 1.0f;
					rgbaThis.fTexel[LSI_PC_G] = fLum / 1.0f;
					rgbaThis.fTexel[LSI_PC_B] = fLum / 1.0f;
					rgbaThis.fTexel[LSI_PC_A] = _bNorm ? StdIntComponentTo32F_Norm<_uABits, _uAShift, _bSigned, false>( (*pui64Src), 1.0f ) : StdIntComponentTo32F<_uABits, _uAShift, _bSigned>( (*pui64Src), 1.0f );
				}
			}
		}
		return true;
	}

	/**
	 * Generic RGBA32F -> luminance/alpha format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uLBits, unsigned _uABits,
		unsigned _uLShift, unsigned _uAShift,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bSrgb>
	bool LSE_CALL CKtx::LumAlphaFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);
					uint64_t * pui64Dst = reinterpret_cast<uint64_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					
					if ( _bNorm ) {
						/*float fLum = rgbaThis.fTexel[LSI_PC_R] * LSI_R_WEIGHT +
							rgbaThis.fTexel[LSI_PC_G] * LSI_G_WEIGHT +
							rgbaThis.fTexel[LSI_PC_B] * LSI_B_WEIGHT;*/
						// Values specified by OpenGL for luminance conversion.
						// https://www.opengl.org/archives/resources/code/samples/advanced/advanced97/notes/node140.html
						float fLum = rgbaThis.fTexel[LSI_PC_R] * 0.3086f +
							rgbaThis.fTexel[LSI_PC_G] * 0.6094f +
							rgbaThis.fTexel[LSI_PC_B] * 0.082f;
						Std32FToIntComponent_Norm<_uLBits, _uLShift, _bSigned, _bSrgb>( fLum, (*pui64Dst) );

						Std32FToIntComponent_Norm<_uABits, _uAShift, _bSigned, false>( rgbaThis.fTexel[LSI_PC_A], (*pui64Dst) );
					}
					else {
						// For integer formats, L is just a copy of R.
						// https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_integer.txt
						float fLum = rgbaThis.fTexel[LSI_PC_R];
						Std32FToIntComponent<_uLBits, _uLShift, _bSigned>( fLum, (*pui64Dst) );

						Std32FToIntComponent<_uABits, _uAShift, _bSigned>( rgbaThis.fTexel[LSI_PC_A], (*pui64Dst) );
					}
				}
			}
		}
		return true;
	}

	/**
	 * Luminance/alpha (floating-point) format -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uLBits, unsigned _uABits,
		unsigned _uLShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool LSE_CALL CKtx::LumAlphaFToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					float fLum = 0.0f;
					float fAlpha = 1.0;
					if ( _uLBits == 16 ) {
						const CFloat16 * pf16Src = reinterpret_cast<const CFloat16 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize+(_uLShift/8)]);
						fLum = static_cast<float>(*pf16Src);
					}
					else if ( _uLBits == 32 ) {
						const float * pf32Src = reinterpret_cast<const float *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize+(_uLShift/8)]);
						fLum = (*pf32Src);
					}
					if ( _uABits == 16 ) {
						const CFloat16 * pf16Src = reinterpret_cast<const CFloat16 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize+(_uAShift/8)]);
						fAlpha = static_cast<float>(*pf16Src);
					}
					else if ( _uABits == 32 ) {
						const float * pf32Src = reinterpret_cast<const float *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize+(_uAShift/8)]);
						fAlpha = (*pf32Src);
					}
					
					rgbaThis.fTexel[LSI_PC_R] = fLum / 1.0f;
					rgbaThis.fTexel[LSI_PC_G] = fLum / 1.0f;
					rgbaThis.fTexel[LSI_PC_B] = fLum / 1.0f;
					rgbaThis.fTexel[LSI_PC_A] = fAlpha;
				}
			}
		}
		return true;
	}

	/**
	 * Generic RGBA32F -> luminance/alpha (floating-point) format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uLBits, unsigned _uABits,
		unsigned _uLShift, unsigned _uAShift,
		unsigned _uTexelSize>
	bool LSE_CALL CKtx::LumAlphaFFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);

					/*float fLum = rgbaThis.fTexel[LSI_PC_R] * LSI_R_WEIGHT +
						rgbaThis.fTexel[LSI_PC_G] * LSI_G_WEIGHT +
						rgbaThis.fTexel[LSI_PC_B] * LSI_B_WEIGHT;*/
					// Values specified by OpenGL for luminance conversion.
					// https://www.opengl.org/archives/resources/code/samples/advanced/advanced97/notes/node140.html
					float fLum = rgbaThis.fTexel[LSI_PC_R] * 0.3086f +
						rgbaThis.fTexel[LSI_PC_G] * 0.6094f +
						rgbaThis.fTexel[LSI_PC_B] * 0.082f;
					
					if ( _uLBits == 16 ) {
						CFloat16 * pf16Dst = reinterpret_cast<CFloat16 *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize+(_uLShift/8)]);
						(*pf16Dst) = fLum;
					}
					else if ( _uLBits == 32 ) {
						float * pf32Dst = reinterpret_cast<float *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize+(_uLShift/8)]);
						(*pf32Dst) = fLum;
					}

					if ( _uABits == 16 ) {
						CFloat16 * pf16Dst = reinterpret_cast<CFloat16 *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize+(_uAShift/8)]);
						(*pf16Dst) = rgbaThis.fTexel[LSI_PC_A];
					}
					else if ( _uABits == 32 ) {
						float * pf32Dst = reinterpret_cast<float *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize+(_uAShift/8)]);
						(*pf32Dst) = rgbaThis.fTexel[LSI_PC_A];
					}
				}
			}
		}
		return true;
	}

	/**
	 * Intensity format -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uIBits,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bFloat>
	bool LSE_CALL CKtx::IntensityToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					float fInt = 0.0;
					if ( _bFloat ) {
						if ( _uIBits == 16 ) {
							const CFloat16 * pf16Src = reinterpret_cast<const CFloat16 *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
							fInt = static_cast<float>(*pf16Src);
						}
						else if ( _uIBits == 32 ) {
							const float * pf32Src = reinterpret_cast<const float *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
							fInt = (*pf32Src);
						}
					}
					else {
						const uint64_t * pui64Src = reinterpret_cast<const uint64_t *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*_uTexelSize]);
						fInt = _bNorm ? StdIntComponentTo32F_Norm<_uIBits, 0, _bSigned, false>( (*pui64Src), 0.0f ) : StdIntComponentTo32F<_uIBits, 0, _bSigned>( (*pui64Src), 0.0f );
					}
					rgbaThis.fTexel[LSI_PC_R] = fInt;
					rgbaThis.fTexel[LSI_PC_G] = fInt;
					rgbaThis.fTexel[LSI_PC_B] = fInt;
					rgbaThis.fTexel[LSI_PC_A] = fInt;
				}
			}
		}
		return true;
	}

	/**
	 * Generic RGBA32F -> intensity format conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template <unsigned _uIBits,
		unsigned _uTexelSize, unsigned _bSigned, unsigned _bNorm, unsigned _bFloat>
	bool LSE_CALL CKtx::IntensityFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( _uTexelSize * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);
					float fInt = (rgbaThis.fTexel[LSI_PC_R] * 0.3086f +
						rgbaThis.fTexel[LSI_PC_G] * 0.6094f +
						rgbaThis.fTexel[LSI_PC_B] * 0.082f) * rgbaThis.fTexel[LSI_PC_A];

					if ( _bFloat ) {
						if ( _uIBits == 16 ) {
							CFloat16 * pf16Dst = reinterpret_cast<CFloat16 *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
							(*pf16Dst) = fInt;
						}
						else if ( _uIBits == 32 ) {
							float * pf32Dst = reinterpret_cast<float *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
							(*pf32Dst) = fInt;
						}
					}
					else {
						uint64_t * pui64Dst = reinterpret_cast<uint64_t *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*_uTexelSize]);
					
						if ( _bNorm ) {
							Std32FToIntComponent_Norm<_uIBits, 0, _bSigned, false>( fInt, (*pui64Dst) );
						}
						else {
							Std32FToIntComponent<_uIBits, 0, _bSigned>( fInt, (*pui64Dst) );
						}
					}
				}
			}
		}
		return true;
	}

	/**
	 * Stencil-X -> RGBA32F conversion.
	 *
	 * \param _pui8Src Source texels.
	 * \param _pui8Dst Destination texels known to be in RGBA32F format.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template<typename _tType, unsigned _uBits>
	bool LSE_CALL CKtx::StencilXToRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};
		const uint64_t ui64RowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const uint64_t ui64SrcRowSize = LSE_ROUND_UP( sizeof( _tType ) * _ui32Width, 4ULL );
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const float fNormFactor = (1 << _uBits) - 1.0f;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					LSI_RGBA32F & rgbaThis = reinterpret_cast<LSI_RGBA32F &>(_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(LSI_RGBA32F)]);
					const _tType * prSrc = reinterpret_cast<const _tType *>(&_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(_tType)]);
					rgbaThis.fTexel[LSI_PC_R] = 0.0f;
					rgbaThis.fTexel[LSI_PC_G] = 0.0f;
					rgbaThis.fTexel[LSI_PC_B] = 0.0f;
					rgbaThis.fTexel[LSI_PC_A] = (*prSrc) / fNormFactor;
				}
			}
		}
		return true;
	}

	/**
	 * RGBA32F -> Stencil-X conversion.
	 *
	 * \param _pui8Src Source texels known to be in RGBA32F format.
	 * \param _pui8Dst Destination texels.
	 * \param _ui32Width Width of the image.
	 * \param _ui32Height Height of the image.
	 * \param _ui32Depth Depth of the image.
	 * \param _pvParms Optional parameters for the conversion.
	 */
	template<typename _tType, unsigned _uBits>
	bool LSE_CALL CKtx::StencilXFromRgba32F( const uint8_t * _pui8Src, uint8_t * _pui8Dst, uint32_t _ui32Width, uint32_t _ui32Height, uint32_t _ui32Depth, void * /*_pvParms*/ ) {
		struct LSI_RGBA32F {
			float fTexel[4];
		};		
		const uint64_t ui64SrcRowSize = sizeof( LSI_RGBA32F ) * _ui32Width;
		const uint64_t ui64SrcPlaneSize = ui64SrcRowSize * _ui32Height;
		const uint64_t ui64RowSize = LSE_ROUND_UP( sizeof( _tType ) * _ui32Width, 4ULL );
		const uint64_t ui64PlaneSize = ui64RowSize * _ui32Height;
		const float fNormFactor = (1 << _uBits) - 0.5f;
		for ( uint32_t Z = 0; Z < _ui32Depth; ++Z ) {
			for ( uint32_t Y = 0; Y < _ui32Height; ++Y ) {
				for ( uint32_t X = 0; X < _ui32Width; ++X ) {
					const LSI_RGBA32F & rgbaThis = reinterpret_cast<const LSI_RGBA32F &>(_pui8Src[Z*ui64SrcPlaneSize+Y*ui64SrcRowSize+X*sizeof(LSI_RGBA32F)]);
					_tType * prDst = reinterpret_cast<_tType *>(&_pui8Dst[Z*ui64PlaneSize+Y*ui64RowSize+X*sizeof(_tType)]);
					
					(*prDst) = static_cast<_tType>(rgbaThis.fTexel[LSI_PC_A] * fNormFactor);
				}
			}
		}
		return true;
	}

}	// namespace lsi

#pragma warning( pop )

#undef LSI_FLOAT10
#undef LSI_FLOAT11

#ifdef LSI_USE_KHRONOS
#endif	// LSI_USE_KHRONOS

#endif	// __LSI_KTX_H__
